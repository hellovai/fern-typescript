// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": ".pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
node_modules
.DS_Store
*.d.ts
*.js
*.js.map",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../core\\";
import { Client as AdminServiceClient } from \\"./admin/client/Client\\";
import { Client as HomepageProblemServiceClient } from \\"./homepage/client/Client\\";
import { Client as MigrationInfoServiceClient } from \\"./migration/client/Client\\";
import { Client as PlaylistCrudServiceClient } from \\"./playlist/client/Client\\";
import { Client as ProblemCrudServiceClient } from \\"./problem/client/Client\\";
import { Client as ExecutionSesssionManagementServiceClient } from \\"./submission/client/Client\\";
import { Client as SysPropCrudServiceClient } from \\"./sysprop/client/Client\\";
import { Wrapper as V2Wrapper } from \\"./v2/Wrapper\\";

export namespace Client {
  export interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #admin: AdminServiceClient | undefined;

  public get admin(): AdminServiceClient {
    return (this.#admin ??= new AdminServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #homepage: HomepageProblemServiceClient | undefined;

  public get homepage(): HomepageProblemServiceClient {
    return (this.#homepage ??= new HomepageProblemServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #migration: MigrationInfoServiceClient | undefined;

  public get migration(): MigrationInfoServiceClient {
    return (this.#migration ??= new MigrationInfoServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #playlist: PlaylistCrudServiceClient | undefined;

  public get playlist(): PlaylistCrudServiceClient {
    return (this.#playlist ??= new PlaylistCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #problem: ProblemCrudServiceClient | undefined;

  public get problem(): ProblemCrudServiceClient {
    return (this.#problem ??= new ProblemCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #submission: ExecutionSesssionManagementServiceClient | undefined;

  public get submission(): ExecutionSesssionManagementServiceClient {
    return (this.#submission ??= new ExecutionSesssionManagementServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #sysprop: SysPropCrudServiceClient | undefined;

  public get sysprop(): SysPropCrudServiceClient {
    return (this.#sysprop ??= new SysPropCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v2: V2Wrapper | undefined;

  public get v2(): V2Wrapper {
    return (this.#v2 ??= new V2Wrapper(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  updateTestSubmissionStatus(
    request: TraceApi.admin.updateTestSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateTestSubmissionStatus.Response>;
  sendTestSubmissionUpdate(
    request: TraceApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendTestSubmissionUpdate.Response>;
  updateWorkspaceSubmissionStatus(
    request: TraceApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateWorkspaceSubmissionStatus.Response>;
  sendWorkspaceSubmissionUpdate(
    request: TraceApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendWorkspaceSubmissionUpdate.Response>;
  storeTracedTestCase(
    request: TraceApi.admin.storeTracedTestCase.Request
  ): Promise<TraceApi.admin.storeTracedTestCase.Response>;
  storeTracedTestCaseV2(
    request: TraceApi.admin.storeTracedTestCaseV2.Request
  ): Promise<TraceApi.admin.storeTracedTestCaseV2.Response>;
  storeTracedWorkspace(
    request: TraceApi.admin.storeTracedWorkspace.Request
  ): Promise<TraceApi.admin.storeTracedWorkspace.Response>;
  storeTracedWorkspaceV2(
    request: TraceApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<TraceApi.admin.storeTracedWorkspaceV2.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    request: TraceApi.admin.updateTestSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateTestSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-test-submission-status/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.submission.TestSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendTestSubmissionUpdate(
    request: TraceApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendTestSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-test-submission-status-v2/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.submission.TestSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateWorkspaceSubmissionStatus(
    request: TraceApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-workspace-submission-status/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.submission.WorkspaceSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    request: TraceApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-workspace-submission-status-v2/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.submission.WorkspaceSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCase(
    request: TraceApi.admin.storeTracedTestCase.Request
  ): Promise<TraceApi.admin.storeTracedTestCase.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.admin.StoreTracedTestCaseRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCaseV2(
    request: TraceApi.admin.storeTracedTestCaseV2.Request
  ): Promise<TraceApi.admin.storeTracedTestCaseV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.admin.storeTracedTestCaseV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspace(
    request: TraceApi.admin.storeTracedWorkspace.Request
  ): Promise<TraceApi.admin.storeTracedWorkspace.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-workspace-trace/submission/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.admin.StoreTracedWorkspaceRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspaceV2(
    request: TraceApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<TraceApi.admin.storeTracedWorkspaceV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/admin/store-workspace-trace-v2/submission/\${request.submissionId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.admin.storeTracedWorkspaceV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.submission.TestSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceApi.admin.sendTestSubmissionUpdate.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendTestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.submission.WorkspaceSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceApi.admin.sendWorkspaceSubmissionUpdate.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendWorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  testCaseId: string;
  _body: TraceApi.admin.StoreTracedTestCaseRequest;
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCase.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  testCaseId: TraceApi.v2.problem.TestCaseId;
  _body: TraceApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCaseV2.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.admin.StoreTracedWorkspaceRequest;
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspace.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspace.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspaceV2.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.submission.TestSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceApi.admin.updateTestSubmissionStatus.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateTestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  submissionId: TraceApi.submission.SubmissionId;
  _body: TraceApi.submission.WorkspaceSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceApi.admin.updateWorkspaceSubmissionStatus.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateWorkspaceSubmissionStatus.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoreTracedTestCaseRequest {
  result: TraceApi.submission.TestCaseResultWithStdout;
  traceResponses: TraceApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: TraceApi.submission.WorkspaceRunDetails;
  traceResponses: TraceApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeNodeAndTreeValue {
  nodeId: TraceApi.commons.NodeId;
  fullTree: TraceApi.commons.BinaryTreeValue;
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeNodeValue {
  nodeId: TraceApi.commons.NodeId;
  val: number;
  right?: TraceApi.commons.NodeId;
  left?: TraceApi.commons.NodeId;
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeValue {
  root?: TraceApi.commons.NodeId;
  nodes: Record<string, TraceApi.commons.BinaryTreeNodeValue>;
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DebugKeyValuePairs {
  key: TraceApi.commons.DebugVariableValue;
  value: TraceApi.commons.DebugVariableValue;
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DebugMapValue {
  keyValuePairs: TraceApi.commons.DebugKeyValuePairs[];
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type DebugVariableValue =
  | DebugVariableValue.IntegerValue
  | DebugVariableValue.BooleanValue
  | DebugVariableValue.DoubleValue
  | DebugVariableValue.StringValue
  | DebugVariableValue.CharValue
  | DebugVariableValue.MapValue
  | DebugVariableValue.ListValue
  | DebugVariableValue.BinaryTreeNodeValue
  | DebugVariableValue.SinglyLinkedListNodeValue
  | DebugVariableValue.DoublyLinkedListNodeValue
  | DebugVariableValue.UndefinedValue
  | DebugVariableValue.NullValue
  | DebugVariableValue.GenericValue
  | DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.commons.DebugMapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.commons.DebugVariableValue[];
  }

  interface BinaryTreeNodeValue extends TraceApi.commons.BinaryTreeNodeAndTreeValue, _Utils {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends TraceApi.commons.SinglyLinkedListNodeAndListValue, _Utils {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends TraceApi.commons.DoublyLinkedListNodeAndListValue, _Utils {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue extends _Utils {
    type: \\"undefinedValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface GenericValue extends TraceApi.commons.GenericValue, _Utils {
    type: \\"genericValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: DebugVariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: TraceApi.commons.DebugMapValue) => Result;
    listValue: (value: TraceApi.commons.DebugVariableValue[]) => Result;
    binaryTreeNodeValue: (value: TraceApi.commons.BinaryTreeNodeAndTreeValue) => Result;
    singlyLinkedListNodeValue: (value: TraceApi.commons.SinglyLinkedListNodeAndListValue) => Result;
    doublyLinkedListNodeValue: (value: TraceApi.commons.DoublyLinkedListNodeAndListValue) => Result;
    undefinedValue: () => Result;
    nullValue: () => Result;
    genericValue: (value: TraceApi.commons.GenericValue) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const DebugVariableValue = {
  integerValue: (value: number): DebugVariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.IntegerValue;
    castedValue._visit = (visitor) => visitor.integerValue(value);
    return castedValue;
  },

  booleanValue: (value: boolean): DebugVariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.BooleanValue;
    castedValue._visit = (visitor) => visitor.booleanValue(value);
    return castedValue;
  },

  doubleValue: (value: number): DebugVariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.DoubleValue;
    castedValue._visit = (visitor) => visitor.doubleValue(value);
    return castedValue;
  },

  stringValue: (value: string): DebugVariableValue.StringValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.StringValue;
    castedValue._visit = (visitor) => visitor.stringValue(value);
    return castedValue;
  },

  charValue: (value: string): DebugVariableValue.CharValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.CharValue;
    castedValue._visit = (visitor) => visitor.charValue(value);
    return castedValue;
  },

  mapValue: (value: TraceApi.commons.DebugMapValue): DebugVariableValue.MapValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.MapValue;
    castedValue._visit = (visitor) => visitor.mapValue(value);
    return castedValue;
  },

  listValue: (value: TraceApi.commons.DebugVariableValue[]): DebugVariableValue.ListValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.ListValue;
    castedValue._visit = (visitor) => visitor.listValue(value);
    return castedValue;
  },

  binaryTreeNodeValue: (value: TraceApi.commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.BinaryTreeNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.BinaryTreeNodeValue;
    castedValue._visit = (visitor) => visitor.binaryTreeNodeValue(value);
    return castedValue;
  },

  singlyLinkedListNodeValue: (
    value: TraceApi.commons.SinglyLinkedListNodeAndListValue
  ): DebugVariableValue.SinglyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.SinglyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.SinglyLinkedListNodeValue;
    castedValue._visit = (visitor) => visitor.singlyLinkedListNodeValue(value);
    return castedValue;
  },

  doublyLinkedListNodeValue: (
    value: TraceApi.commons.DoublyLinkedListNodeAndListValue
  ): DebugVariableValue.DoublyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.DoublyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.DoublyLinkedListNodeValue;
    castedValue._visit = (visitor) => visitor.doublyLinkedListNodeValue(value);
    return castedValue;
  },

  undefinedValue: (): DebugVariableValue.UndefinedValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.UndefinedValue, \\"_visit\\"> = {
      type: \\"undefinedValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.UndefinedValue;
    castedValue._visit = (visitor) => visitor.undefinedValue();
    return castedValue;
  },

  nullValue: (): DebugVariableValue.NullValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.NullValue;
    castedValue._visit = (visitor) => visitor.nullValue();
    return castedValue;
  },

  genericValue: (value: TraceApi.commons.GenericValue): DebugVariableValue.GenericValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.GenericValue, \\"_visit\\"> = {
      ...value,
      type: \\"genericValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.GenericValue;
    castedValue._visit = (visitor) => visitor.genericValue(value);
    return castedValue;
  },
} as const;
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListNodeAndListValue {
  nodeId: TraceApi.commons.NodeId;
  fullList: TraceApi.commons.DoublyLinkedListValue;
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListNodeValue {
  nodeId: TraceApi.commons.NodeId;
  val: number;
  next?: TraceApi.commons.NodeId;
  prev?: TraceApi.commons.NodeId;
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListValue {
  head?: TraceApi.commons.NodeId;
  nodes: Record<string, TraceApi.commons.DoublyLinkedListNodeValue>;
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfo {
  filename: string;
  contents: string;
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericValue {
  stringifiedType?: string;
  stringifiedValue: string;
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface KeyValuePair {
  key: TraceApi.commons.VariableValue;
  value: TraceApi.commons.VariableValue;
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface Language<RawValue extends Language.RawValue = Language.RawValue> {
  toString: () => RawValue;
  visit: <Result>(visitor: Language._Visitor<Result>) => Result;
}

const _Java: Language<\\"JAVA\\"> = {
  toString: () => \\"JAVA\\",
  visit: (visitor) => visitor.java(),
};
const _Javascript: Language<\\"JAVASCRIPT\\"> = {
  toString: () => \\"JAVASCRIPT\\",
  visit: (visitor) => visitor.javascript(),
};
const _Python: Language<\\"PYTHON\\"> = {
  toString: () => \\"PYTHON\\",
  visit: (visitor) => visitor.python(),
};
export const Language = {
  Java: _Java,
  Javascript: _Javascript,
  Python: _Python,
} as const;

export declare namespace Language {
  type RawValue = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\" | string;

  interface _Visitor<Result> {
    java: () => Result;
    javascript: () => Result;
    python: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ListType {
  valueType: TraceApi.commons.VariableType;
  /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
  isFixedLength?: boolean;
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface MapType {
  keyType: TraceApi.commons.VariableType;
  valueType: TraceApi.commons.VariableType;
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface MapValue {
  keyValuePairs: TraceApi.commons.KeyValuePair[];
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type NodeId = string;
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ProblemId = string;
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListNodeAndListValue {
  nodeId: TraceApi.commons.NodeId;
  fullList: TraceApi.commons.SinglyLinkedListValue;
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListNodeValue {
  nodeId: TraceApi.commons.NodeId;
  val: number;
  next?: TraceApi.commons.NodeId;
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListValue {
  head?: TraceApi.commons.NodeId;
  nodes: Record<string, TraceApi.commons.SinglyLinkedListNodeValue>;
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCase {
  id: string;
  params: TraceApi.commons.VariableValue[];
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseWithExpectedResult {
  testCase: TraceApi.commons.TestCase;
  expectedResult: TraceApi.commons.VariableValue;
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type UserId = string;
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type VariableType =
  | VariableType.IntegerType
  | VariableType.DoubleType
  | VariableType.BooleanType
  | VariableType.StringType
  | VariableType.CharType
  | VariableType.ListType
  | VariableType.MapType
  | VariableType.BinaryTreeType
  | VariableType.SinglyLinkedListType
  | VariableType.DoublyLinkedListType
  | VariableType._Unknown;

export declare namespace VariableType {
  interface IntegerType extends _Utils {
    type: \\"integerType\\";
  }

  interface DoubleType extends _Utils {
    type: \\"doubleType\\";
  }

  interface BooleanType extends _Utils {
    type: \\"booleanType\\";
  }

  interface StringType extends _Utils {
    type: \\"stringType\\";
  }

  interface CharType extends _Utils {
    type: \\"charType\\";
  }

  interface ListType extends TraceApi.commons.ListType, _Utils {
    type: \\"listType\\";
  }

  interface MapType extends TraceApi.commons.MapType, _Utils {
    type: \\"mapType\\";
  }

  interface BinaryTreeType extends _Utils {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType extends _Utils {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType extends _Utils {
    type: \\"doublyLinkedListType\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableType._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerType: () => Result;
    doubleType: () => Result;
    booleanType: () => Result;
    stringType: () => Result;
    charType: () => Result;
    listType: (value: TraceApi.commons.ListType) => Result;
    mapType: (value: TraceApi.commons.MapType) => Result;
    binaryTreeType: () => Result;
    singlyLinkedListType: () => Result;
    doublyLinkedListType: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableType = {
  integerType: (): VariableType.IntegerType => {
    const valueWithoutVisit: Omit<VariableType.IntegerType, \\"_visit\\"> = {
      type: \\"integerType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.IntegerType;
    castedValue._visit = (visitor) => visitor.integerType();
    return castedValue;
  },

  doubleType: (): VariableType.DoubleType => {
    const valueWithoutVisit: Omit<VariableType.DoubleType, \\"_visit\\"> = {
      type: \\"doubleType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.DoubleType;
    castedValue._visit = (visitor) => visitor.doubleType();
    return castedValue;
  },

  booleanType: (): VariableType.BooleanType => {
    const valueWithoutVisit: Omit<VariableType.BooleanType, \\"_visit\\"> = {
      type: \\"booleanType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.BooleanType;
    castedValue._visit = (visitor) => visitor.booleanType();
    return castedValue;
  },

  stringType: (): VariableType.StringType => {
    const valueWithoutVisit: Omit<VariableType.StringType, \\"_visit\\"> = {
      type: \\"stringType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.StringType;
    castedValue._visit = (visitor) => visitor.stringType();
    return castedValue;
  },

  charType: (): VariableType.CharType => {
    const valueWithoutVisit: Omit<VariableType.CharType, \\"_visit\\"> = {
      type: \\"charType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.CharType;
    castedValue._visit = (visitor) => visitor.charType();
    return castedValue;
  },

  listType: (value: TraceApi.commons.ListType): VariableType.ListType => {
    const valueWithoutVisit: Omit<VariableType.ListType, \\"_visit\\"> = {
      ...value,
      type: \\"listType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.ListType;
    castedValue._visit = (visitor) => visitor.listType(value);
    return castedValue;
  },

  mapType: (value: TraceApi.commons.MapType): VariableType.MapType => {
    const valueWithoutVisit: Omit<VariableType.MapType, \\"_visit\\"> = {
      ...value,
      type: \\"mapType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.MapType;
    castedValue._visit = (visitor) => visitor.mapType(value);
    return castedValue;
  },

  binaryTreeType: (): VariableType.BinaryTreeType => {
    const valueWithoutVisit: Omit<VariableType.BinaryTreeType, \\"_visit\\"> = {
      type: \\"binaryTreeType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.BinaryTreeType;
    castedValue._visit = (visitor) => visitor.binaryTreeType();
    return castedValue;
  },

  singlyLinkedListType: (): VariableType.SinglyLinkedListType => {
    const valueWithoutVisit: Omit<VariableType.SinglyLinkedListType, \\"_visit\\"> = {
      type: \\"singlyLinkedListType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.SinglyLinkedListType;
    castedValue._visit = (visitor) => visitor.singlyLinkedListType();
    return castedValue;
  },

  doublyLinkedListType: (): VariableType.DoublyLinkedListType => {
    const valueWithoutVisit: Omit<VariableType.DoublyLinkedListType, \\"_visit\\"> = {
      type: \\"doublyLinkedListType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.DoublyLinkedListType;
    castedValue._visit = (visitor) => visitor.doublyLinkedListType();
    return castedValue;
  },
} as const;
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type VariableValue =
  | VariableValue.IntegerValue
  | VariableValue.BooleanValue
  | VariableValue.DoubleValue
  | VariableValue.StringValue
  | VariableValue.CharValue
  | VariableValue.MapValue
  | VariableValue.ListValue
  | VariableValue.BinaryTreeValue
  | VariableValue.SinglyLinkedListValue
  | VariableValue.DoublyLinkedListValue
  | VariableValue.NullValue
  | VariableValue._Unknown;

export declare namespace VariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.commons.MapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.commons.VariableValue[];
  }

  interface BinaryTreeValue extends TraceApi.commons.BinaryTreeValue, _Utils {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends TraceApi.commons.SinglyLinkedListValue, _Utils {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends TraceApi.commons.DoublyLinkedListValue, _Utils {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: TraceApi.commons.MapValue) => Result;
    listValue: (value: TraceApi.commons.VariableValue[]) => Result;
    binaryTreeValue: (value: TraceApi.commons.BinaryTreeValue) => Result;
    singlyLinkedListValue: (value: TraceApi.commons.SinglyLinkedListValue) => Result;
    doublyLinkedListValue: (value: TraceApi.commons.DoublyLinkedListValue) => Result;
    nullValue: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableValue = {
  integerValue: (value: number): VariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<VariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.IntegerValue;
    castedValue._visit = (visitor) => visitor.integerValue(value);
    return castedValue;
  },

  booleanValue: (value: boolean): VariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<VariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.BooleanValue;
    castedValue._visit = (visitor) => visitor.booleanValue(value);
    return castedValue;
  },

  doubleValue: (value: number): VariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<VariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.DoubleValue;
    castedValue._visit = (visitor) => visitor.doubleValue(value);
    return castedValue;
  },

  stringValue: (value: string): VariableValue.StringValue => {
    const valueWithoutVisit: Omit<VariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.StringValue;
    castedValue._visit = (visitor) => visitor.stringValue(value);
    return castedValue;
  },

  charValue: (value: string): VariableValue.CharValue => {
    const valueWithoutVisit: Omit<VariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.CharValue;
    castedValue._visit = (visitor) => visitor.charValue(value);
    return castedValue;
  },

  mapValue: (value: TraceApi.commons.MapValue): VariableValue.MapValue => {
    const valueWithoutVisit: Omit<VariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.MapValue;
    castedValue._visit = (visitor) => visitor.mapValue(value);
    return castedValue;
  },

  listValue: (value: TraceApi.commons.VariableValue[]): VariableValue.ListValue => {
    const valueWithoutVisit: Omit<VariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.ListValue;
    castedValue._visit = (visitor) => visitor.listValue(value);
    return castedValue;
  },

  binaryTreeValue: (value: TraceApi.commons.BinaryTreeValue): VariableValue.BinaryTreeValue => {
    const valueWithoutVisit: Omit<VariableValue.BinaryTreeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.BinaryTreeValue;
    castedValue._visit = (visitor) => visitor.binaryTreeValue(value);
    return castedValue;
  },

  singlyLinkedListValue: (value: TraceApi.commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => {
    const valueWithoutVisit: Omit<VariableValue.SinglyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.SinglyLinkedListValue;
    castedValue._visit = (visitor) => visitor.singlyLinkedListValue(value);
    return castedValue;
  },

  doublyLinkedListValue: (value: TraceApi.commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => {
    const valueWithoutVisit: Omit<VariableValue.DoublyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.DoublyLinkedListValue;
    castedValue._visit = (visitor) => visitor.doublyLinkedListValue(value);
    return castedValue;
  },

  nullValue: (): VariableValue.NullValue => {
    const valueWithoutVisit: Omit<VariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.NullValue;
    castedValue._visit = (visitor) => visitor.nullValue();
    return castedValue;
  },
} as const;
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getHomepageProblems(): Promise<TraceApi.homepage.getHomepageProblems.Response>;
  setHomepageProblems(request: TraceApi.commons.ProblemId[]): Promise<TraceApi.homepage.setHomepageProblems.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<TraceApi.homepage.getHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.homepage.getHomepageProblems.Response.parse(response.body as schemas.commons.ProblemId.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async setHomepageProblems(
    request: TraceApi.commons.ProblemId[]
  ): Promise<TraceApi.homepage.setHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.homepage.setHomepageProblems.Request.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.commons.ProblemId[], TraceApi.homepage.getHomepageProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.homepage.setHomepageProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerRequest {
  request?: unknown;
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerResponse {
  response?: unknown;
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getAttemptedMigrations(): Promise<TraceApi.migration.getAttemptedMigrations.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<TraceApi.migration.getAttemptedMigrations.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.migration.getAttemptedMigrations.Response.parse(
          response.body as schemas.migration.Migration.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.migration.Migration[],
  TraceApi.migration.getAttemptedMigrations.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Migration {
  name: string;
  status: TraceApi.migration.MigrationStatus;
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface MigrationStatus<RawValue extends MigrationStatus.RawValue = MigrationStatus.RawValue> {
  toString: () => RawValue;
  visit: <Result>(visitor: MigrationStatus._Visitor<Result>) => Result;
}

const _Running: MigrationStatus<\\"RUNNING\\"> = {
  toString: () => \\"RUNNING\\",
  visit: (visitor) => visitor.running(),
};
const _Failed: MigrationStatus<\\"FAILED\\"> = {
  toString: () => \\"FAILED\\",
  visit: (visitor) => visitor.failed(),
};
const _Finished: MigrationStatus<\\"FINISHED\\"> = {
  toString: () => \\"FINISHED\\",
  visit: (visitor) => visitor.finished(),
};
export const MigrationStatus = {
  Running: _Running,
  Failed: _Failed,
  Finished: _Finished,
} as const;

export declare namespace MigrationStatus {
  type RawValue = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\" | string;

  interface _Visitor<Result> {
    running: () => Result;
    failed: () => Result;
    finished: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createPlaylist(request: TraceApi.playlist.createPlaylist.Request): Promise<TraceApi.playlist.createPlaylist.Response>;
  getPlaylists(request: TraceApi.playlist.getPlaylists.Request): Promise<TraceApi.playlist.getPlaylists.Response>;
  getPlaylist(request: TraceApi.playlist.getPlaylist.Request): Promise<TraceApi.playlist.getPlaylist.Response>;
  updatePlaylist(request: TraceApi.playlist.updatePlaylist.Request): Promise<TraceApi.playlist.updatePlaylist.Response>;
  deletePlaylist(request: TraceApi.playlist.deletePlaylist.Request): Promise<TraceApi.playlist.deletePlaylist.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    request: TraceApi.playlist.createPlaylist.Request
  ): Promise<TraceApi.playlist.createPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/v2/playlist/\${request.serviceParam}create\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.playlist.PlaylistCreateRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(response.body as schemas.playlist.Playlist.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylists(
    request: TraceApi.playlist.getPlaylists.Request
  ): Promise<TraceApi.playlist.getPlaylists.Response> {
    const queryParameters = new URLSearchParams();
    if (request.limit != null) {
      queryParameters.append(\\"limit\\", request.limit.toString());
    }

    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/v2/playlist/\${request.serviceParam}all\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      queryParameters: queryParameters,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.getPlaylists.Response.parse(response.body as schemas.playlist.Playlist.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylist(
    request: TraceApi.playlist.getPlaylist.Request
  ): Promise<TraceApi.playlist.getPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(response.body as schemas.playlist.Playlist.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as schemas.playlist.getPlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: schemas.playlist.getPlaylist.Error.parse(
              response.error.body as schemas.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updatePlaylist(
    request: TraceApi.playlist.updatePlaylist.Request
  ): Promise<TraceApi.playlist.updatePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`),
      method: \\"PUT\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.playlist.updatePlaylist.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.updatePlaylist.Response.parse(
          response.body as schemas.playlist.Playlist.Raw | null | undefined
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as schemas.playlist.updatePlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: schemas.playlist.updatePlaylist.Error.parse(
              response.error.body as schemas.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deletePlaylist(
    request: TraceApi.playlist.deletePlaylist.Request
  ): Promise<TraceApi.playlist.deletePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  serviceParam: number;
  _body: TraceApi.playlist.PlaylistCreateRequest;
}

export type Response = core.APIResponse<TraceApi.playlist.Playlist, TraceApi.playlist.createPlaylist.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  serviceParam: number;
  playlistId: TraceApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<void, TraceApi.playlist.deletePlaylist.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deletePlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  serviceParam: number;
  playlistId: TraceApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<TraceApi.playlist.Playlist, TraceApi.playlist.getPlaylist.Error>;
export type Error = Error.PlaylistIdNotFoundError | Error.UnauthorizedError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.playlist.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (value: TraceApi.playlist.PlaylistIdNotFoundError) => Result;
    unauthorizedError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (value: TraceApi.playlist.PlaylistIdNotFoundError): Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.PlaylistIdNotFoundError;
    castedValue._visit = (visitor) => visitor.playlistIdNotFoundError(value);
    return castedValue;
  },

  unauthorizedError: (): Error.UnauthorizedError => {
    const valueWithoutVisit: Omit<Error.UnauthorizedError, \\"_visit\\"> = {
      errorName: \\"UnauthorizedError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.UnauthorizedError;
    castedValue._visit = (visitor) => visitor.unauthorizedError();
    return castedValue;
  },
} as const;
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  limit?: number;
  serviceParam: number;
}

export type Response = core.APIResponse<TraceApi.playlist.Playlist[], TraceApi.playlist.getPlaylists.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  serviceParam: number;
  playlistId: TraceApi.playlist.PlaylistId;
  _body?: TraceApi.playlist.UpdatePlaylistRequest;
}

export type Response = core.APIResponse<TraceApi.playlist.Playlist | undefined, TraceApi.playlist.updatePlaylist.Error>;
export type Error = Error.PlaylistIdNotFoundError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.playlist.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (value: TraceApi.playlist.PlaylistIdNotFoundError) => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (value: TraceApi.playlist.PlaylistIdNotFoundError): Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.PlaylistIdNotFoundError;
    castedValue._visit = (visitor) => visitor.playlistIdNotFoundError(value);
    return castedValue;
  },
} as const;
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type PlaylistIdNotFoundError = PlaylistIdNotFoundError.PlaylistId | PlaylistIdNotFoundError._Unknown;

export declare namespace PlaylistIdNotFoundError {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: TraceApi.playlist.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: PlaylistIdNotFoundError._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistId: (value: TraceApi.playlist.PlaylistId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const PlaylistIdNotFoundError = {
  playlistId: (value: TraceApi.playlist.PlaylistId): PlaylistIdNotFoundError.PlaylistId => {
    const valueWithoutVisit: Omit<PlaylistIdNotFoundError.PlaylistId, \\"_visit\\"> = {
      value: value,
      type: \\"playlistId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as PlaylistIdNotFoundError.PlaylistId;
    castedValue._visit = (visitor) => visitor.playlistId(value);
    return castedValue;
  },
} as const;
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Playlist extends TraceApi.playlist.PlaylistCreateRequest {
  playlistId: TraceApi.playlist.PlaylistId;
  ownerId: TraceApi.commons.UserId;
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface PlaylistCreateRequest {
  name: string;
  problems: TraceApi.commons.ProblemId[];
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type PlaylistId = string;
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface UpdatePlaylistRequest {
  name: string;
  problems: TraceApi.commons.ProblemId[];
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createProblem(request: TraceApi.problem.CreateProblemRequest): Promise<TraceApi.problem.createProblem.Response>;
  updateProblem(request: TraceApi.problem.updateProblem.Request): Promise<TraceApi.problem.updateProblem.Response>;
  deleteProblem(request: TraceApi.problem.deleteProblem.Request): Promise<TraceApi.problem.deleteProblem.Response>;
  getDefaultStarterFiles(
    request: TraceApi.problem.GetDefaultStarterFilesRequest
  ): Promise<TraceApi.problem.getDefaultStarterFiles.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(
    request: TraceApi.problem.CreateProblemRequest
  ): Promise<TraceApi.problem.createProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.problem.CreateProblemRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.CreateProblemResponse.parse(response.body as schemas.problem.CreateProblemResponse.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateProblem(
    request: TraceApi.problem.updateProblem.Request
  ): Promise<TraceApi.problem.updateProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/problem-crud/update/\${request.problemId}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.problem.CreateProblemRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.UpdateProblemResponse.parse(response.body as schemas.problem.UpdateProblemResponse.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deleteProblem(
    request: TraceApi.problem.deleteProblem.Request
  ): Promise<TraceApi.problem.deleteProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/problem-crud/delete/\${request.problemId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getDefaultStarterFiles(
    request: TraceApi.problem.GetDefaultStarterFilesRequest
  ): Promise<TraceApi.problem.getDefaultStarterFiles.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
      body: schemas.problem.GetDefaultStarterFilesRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.GetDefaultStarterFilesResponse.parse(
          response.body as schemas.problem.GetDefaultStarterFilesResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.problem.CreateProblemResponse, TraceApi.problem.createProblem.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
}

export type Response = core.APIResponse<void, TraceApi.problem.deleteProblem.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deleteProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.problem.GetDefaultStarterFilesResponse,
  TraceApi.problem.getDefaultStarterFiles.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getDefaultStarterFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
  _body: TraceApi.problem.CreateProblemRequest;
}

export type Response = core.APIResponse<TraceApi.problem.UpdateProblemResponse, TraceApi.problem.updateProblem.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateProblem.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type CreateProblemError = CreateProblemError.Generic | CreateProblemError._Unknown;

export declare namespace CreateProblemError {
  interface Generic extends TraceApi.problem.GenericCreateProblemError, _Utils {
    errorType: \\"generic\\";
  }

  interface _Unknown extends _Utils {
    errorType: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemError._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: TraceApi.problem.GenericCreateProblemError) => Result;
    _other: (value: { errorType: string }) => Result;
  }
}

export const CreateProblemError = {
  generic: (value: TraceApi.problem.GenericCreateProblemError): CreateProblemError.Generic => {
    const valueWithoutVisit: Omit<CreateProblemError.Generic, \\"_visit\\"> = {
      ...value,
      errorType: \\"generic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemError.Generic;
    castedValue._visit = (visitor) => visitor.generic(value);
    return castedValue;
  },
} as const;
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface CreateProblemRequest {
  problemName: string;
  problemDescription: TraceApi.problem.ProblemDescription;
  files: Record<TraceApi.commons.Language.RawValue, TraceApi.problem.ProblemFiles>;
  inputParams: TraceApi.problem.VariableTypeAndName[];
  outputType: TraceApi.commons.VariableType;
  testcases: TraceApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type CreateProblemResponse =
  | CreateProblemResponse.Success
  | CreateProblemResponse.Error
  | CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
  interface Success extends _Utils {
    type: \\"success\\";
    value: TraceApi.commons.ProblemId;
  }

  interface Error extends _Utils {
    type: \\"error\\";
    value: TraceApi.problem.CreateProblemError;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    success: (value: TraceApi.commons.ProblemId) => Result;
    error: (value: TraceApi.problem.CreateProblemError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CreateProblemResponse = {
  success: (value: TraceApi.commons.ProblemId): CreateProblemResponse.Success => {
    const valueWithoutVisit: Omit<CreateProblemResponse.Success, \\"_visit\\"> = {
      value: value,
      type: \\"success\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemResponse.Success;
    castedValue._visit = (visitor) => visitor.success(value);
    return castedValue;
  },

  error: (value: TraceApi.problem.CreateProblemError): CreateProblemResponse.Error => {
    const valueWithoutVisit: Omit<CreateProblemResponse.Error, \\"_visit\\"> = {
      value: value,
      type: \\"error\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemResponse.Error;
    castedValue._visit = (visitor) => visitor.error(value);
    return castedValue;
  },
} as const;
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericCreateProblemError {
  message: string;
  type: string;
  stacktrace: string;
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: TraceApi.problem.VariableTypeAndName[];
  outputType: TraceApi.commons.VariableType;
  methodName: string;
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetDefaultStarterFilesResponse {
  files: Record<TraceApi.commons.Language.RawValue, TraceApi.problem.ProblemFiles>;
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemDescription {
  boards: TraceApi.problem.ProblemDescriptionBoard[];
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ProblemDescriptionBoard =
  | ProblemDescriptionBoard.Html
  | ProblemDescriptionBoard.Variable
  | ProblemDescriptionBoard.TestCaseId
  | ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface Variable extends _Utils {
    type: \\"variable\\";
    value: TraceApi.commons.VariableValue;
  }

  interface TestCaseId extends _Utils {
    type: \\"testCaseId\\";
    value: string;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ProblemDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    variable: (value: TraceApi.commons.VariableValue) => Result;
    testCaseId: (value: string) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ProblemDescriptionBoard = {
  html: (value: string): ProblemDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  variable: (value: TraceApi.commons.VariableValue): ProblemDescriptionBoard.Variable => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.Variable, \\"_visit\\"> = {
      value: value,
      type: \\"variable\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.Variable;
    castedValue._visit = (visitor) => visitor.variable(value);
    return castedValue;
  },

  testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.TestCaseId, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.TestCaseId;
    castedValue._visit = (visitor) => visitor.testCaseId(value);
    return castedValue;
  },
} as const;
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemFiles {
  solutionFile: TraceApi.commons.FileInfo;
  readOnlyFiles: TraceApi.commons.FileInfo[];
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemInfo {
  problemId: TraceApi.commons.ProblemId;
  problemDescription: TraceApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  files: Record<TraceApi.commons.Language.RawValue, TraceApi.problem.ProblemFiles>;
  inputParams: TraceApi.problem.VariableTypeAndName[];
  outputType: TraceApi.commons.VariableType;
  testcases: TraceApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
  supportsCustomTestCases: boolean;
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface UpdateProblemResponse {
  problemVersion: number;
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface VariableTypeAndName {
  variableType: TraceApi.commons.VariableType;
  name: string;
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createExecutionSession(
    request: TraceApi.submission.createExecutionSession.Request
  ): Promise<TraceApi.submission.createExecutionSession.Response>;
  getExecutionSession(
    request: TraceApi.submission.getExecutionSession.Request
  ): Promise<TraceApi.submission.getExecutionSession.Response>;
  stopExecutionSession(
    request: TraceApi.submission.stopExecutionSession.Request
  ): Promise<TraceApi.submission.stopExecutionSession.Response>;
  getExecutionSessionsState(): Promise<TraceApi.submission.getExecutionSessionsState.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    request: TraceApi.submission.createExecutionSession.Request
  ): Promise<TraceApi.submission.createExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions/create-session/\${request.language}\`),
      method: \\"POST\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.ExecutionSessionResponse.parse(
          response.body as schemas.submission.ExecutionSessionResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSession(
    request: TraceApi.submission.getExecutionSession.Request
  ): Promise<TraceApi.submission.getExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions/\${request.sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.getExecutionSession.Response.parse(
          response.body as schemas.submission.ExecutionSessionResponse.Raw | null | undefined
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async stopExecutionSession(
    request: TraceApi.submission.stopExecutionSession.Request
  ): Promise<TraceApi.submission.stopExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions/stop/\${request.sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSessionsState(): Promise<TraceApi.submission.getExecutionSessionsState.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.GetExecutionSessionStateResponse.parse(
          response.body as schemas.submission.GetExecutionSessionStateResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  language: TraceApi.commons.Language;
}

export type Response = core.APIResponse<
  TraceApi.submission.ExecutionSessionResponse,
  TraceApi.submission.createExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  sessionId: string;
}

export type Response = core.APIResponse<
  TraceApi.submission.ExecutionSessionResponse | undefined,
  TraceApi.submission.getExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.submission.GetExecutionSessionStateResponse,
  TraceApi.submission.getExecutionSessionsState.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSessionsState.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  sessionId: string;
}

export type Response = core.APIResponse<void, TraceApi.submission.stopExecutionSession.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "stopExecutionSession.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ActualResult =
  | ActualResult.Value
  | ActualResult.Exception
  | ActualResult.ExceptionV2
  | ActualResult._Unknown;

export declare namespace ActualResult {
  interface Value extends _Utils {
    type: \\"value\\";
    value: TraceApi.commons.VariableValue;
  }

  interface Exception extends TraceApi.submission.ExceptionInfo, _Utils {
    type: \\"exception\\";
  }

  interface ExceptionV2 extends _Utils {
    type: \\"exceptionV2\\";
    value: TraceApi.submission.ExceptionV2;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ActualResult._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    value: (value: TraceApi.commons.VariableValue) => Result;
    exception: (value: TraceApi.submission.ExceptionInfo) => Result;
    exceptionV2: (value: TraceApi.submission.ExceptionV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ActualResult = {
  value: (value: TraceApi.commons.VariableValue): ActualResult.Value => {
    const valueWithoutVisit: Omit<ActualResult.Value, \\"_visit\\"> = {
      value: value,
      type: \\"value\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.Value;
    castedValue._visit = (visitor) => visitor.value(value);
    return castedValue;
  },

  exception: (value: TraceApi.submission.ExceptionInfo): ActualResult.Exception => {
    const valueWithoutVisit: Omit<ActualResult.Exception, \\"_visit\\"> = {
      ...value,
      type: \\"exception\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.Exception;
    castedValue._visit = (visitor) => visitor.exception(value);
    return castedValue;
  },

  exceptionV2: (value: TraceApi.submission.ExceptionV2): ActualResult.ExceptionV2 => {
    const valueWithoutVisit: Omit<ActualResult.ExceptionV2, \\"_visit\\"> = {
      value: value,
      type: \\"exceptionV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.ExceptionV2;
    castedValue._visit = (visitor) => visitor.exceptionV2(value);
    return castedValue;
  },
} as const;
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BuildingExecutorResponse {
  submissionId: TraceApi.submission.SubmissionId;
  status: TraceApi.submission.ExecutionSessionStatus;
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type CodeExecutionUpdate =
  /**
   * Statuses if an executor for the session isn't ready (Before RunningResponse). */
  | CodeExecutionUpdate.BuildingExecutor
  /**
   * Sent once a test submission is executing. */
  | CodeExecutionUpdate.Running
  /**
   * Sent if a submission cannot be run (i.e. Compile Error). */
  | CodeExecutionUpdate.Errored
  /**
   * Sent if a submission is stopped. */
  | CodeExecutionUpdate.Stopped
  /**
   * Graded testcases without trace information. */
  | CodeExecutionUpdate.Graded
  /**
   * Graded submission for v2 problems. */
  | CodeExecutionUpdate.GradedV2
  /**
   * Workspace run without trace information. */
  | CodeExecutionUpdate.WorkspaceRan
  /**
   * Gives progress about what is being recorded. */
  | CodeExecutionUpdate.Recording
  /**
   * Graded testcases with trace information. */
  | CodeExecutionUpdate.Recorded
  /**
   * Sent if an invalid request is sent for a submission. */
  | CodeExecutionUpdate.InvalidRequest
  /**
   * Sent once a submission is graded and fully recorded. */
  | CodeExecutionUpdate.Finished
  | CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
  interface BuildingExecutor extends TraceApi.submission.BuildingExecutorResponse, _Utils {
    type: \\"buildingExecutor\\";
  }

  interface Running extends TraceApi.submission.RunningResponse, _Utils {
    type: \\"running\\";
  }

  interface Errored extends TraceApi.submission.ErroredResponse, _Utils {
    type: \\"errored\\";
  }

  interface Stopped extends TraceApi.submission.StoppedResponse, _Utils {
    type: \\"stopped\\";
  }

  interface Graded extends TraceApi.submission.GradedResponse, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends TraceApi.submission.GradedResponseV2, _Utils {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends TraceApi.submission.WorkspaceRanResponse, _Utils {
    type: \\"workspaceRan\\";
  }

  interface Recording extends TraceApi.submission.RecordingResponseNotification, _Utils {
    type: \\"recording\\";
  }

  interface Recorded extends TraceApi.submission.RecordedResponseNotification, _Utils {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends TraceApi.submission.InvalidRequestResponse, _Utils {
    type: \\"invalidRequest\\";
  }

  interface Finished extends TraceApi.submission.FinishedResponse, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CodeExecutionUpdate._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    buildingExecutor: (value: TraceApi.submission.BuildingExecutorResponse) => Result;
    running: (value: TraceApi.submission.RunningResponse) => Result;
    errored: (value: TraceApi.submission.ErroredResponse) => Result;
    stopped: (value: TraceApi.submission.StoppedResponse) => Result;
    graded: (value: TraceApi.submission.GradedResponse) => Result;
    gradedV2: (value: TraceApi.submission.GradedResponseV2) => Result;
    workspaceRan: (value: TraceApi.submission.WorkspaceRanResponse) => Result;
    recording: (value: TraceApi.submission.RecordingResponseNotification) => Result;
    recorded: (value: TraceApi.submission.RecordedResponseNotification) => Result;
    invalidRequest: (value: TraceApi.submission.InvalidRequestResponse) => Result;
    finished: (value: TraceApi.submission.FinishedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CodeExecutionUpdate = {
  buildingExecutor: (value: TraceApi.submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.BuildingExecutor, \\"_visit\\"> = {
      ...value,
      type: \\"buildingExecutor\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.BuildingExecutor;
    castedValue._visit = (visitor) => visitor.buildingExecutor(value);
    return castedValue;
  },

  running: (value: TraceApi.submission.RunningResponse): CodeExecutionUpdate.Running => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Running, \\"_visit\\"> = {
      ...value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  errored: (value: TraceApi.submission.ErroredResponse): CodeExecutionUpdate.Errored => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Errored, \\"_visit\\"> = {
      ...value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  stopped: (value: TraceApi.submission.StoppedResponse): CodeExecutionUpdate.Stopped => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Stopped, \\"_visit\\"> = {
      ...value,
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Stopped;
    castedValue._visit = (visitor) => visitor.stopped(value);
    return castedValue;
  },

  graded: (value: TraceApi.submission.GradedResponse): CodeExecutionUpdate.Graded => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Graded;
    castedValue._visit = (visitor) => visitor.graded(value);
    return castedValue;
  },

  gradedV2: (value: TraceApi.submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.GradedV2, \\"_visit\\"> = {
      ...value,
      type: \\"gradedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.GradedV2;
    castedValue._visit = (visitor) => visitor.gradedV2(value);
    return castedValue;
  },

  workspaceRan: (value: TraceApi.submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.WorkspaceRan, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceRan\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.WorkspaceRan;
    castedValue._visit = (visitor) => visitor.workspaceRan(value);
    return castedValue;
  },

  recording: (value: TraceApi.submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Recording, \\"_visit\\"> = {
      ...value,
      type: \\"recording\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Recording;
    castedValue._visit = (visitor) => visitor.recording(value);
    return castedValue;
  },

  recorded: (value: TraceApi.submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Recorded, \\"_visit\\"> = {
      ...value,
      type: \\"recorded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Recorded;
    castedValue._visit = (visitor) => visitor.recorded(value);
    return castedValue;
  },

  invalidRequest: (value: TraceApi.submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.InvalidRequest, \\"_visit\\"> = {
      ...value,
      type: \\"invalidRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.InvalidRequest;
    castedValue._visit = (visitor) => visitor.invalidRequest(value);
    return castedValue;
  },

  finished: (value: TraceApi.submission.FinishedResponse): CodeExecutionUpdate.Finished => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Finished, \\"_visit\\"> = {
      ...value,
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Finished;
    castedValue._visit = (visitor) => visitor.finished(value);
    return castedValue;
  },
} as const;
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface CompileError {
  message: string;
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface CustomTestCasesUnsupported {
  problemId: TraceApi.commons.ProblemId;
  submissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ErrorInfo =
  | ErrorInfo.CompileError
  /**
   * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
   *  */
  | ErrorInfo.RuntimeError
  /**
   * If the trace backend encounters an unexpected error.
   *  */
  | ErrorInfo.InternalError
  | ErrorInfo._Unknown;

export declare namespace ErrorInfo {
  interface CompileError extends TraceApi.submission.CompileError, _Utils {
    type: \\"compileError\\";
  }

  interface RuntimeError extends TraceApi.submission.RuntimeError, _Utils {
    type: \\"runtimeError\\";
  }

  interface InternalError extends TraceApi.submission.InternalError, _Utils {
    type: \\"internalError\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ErrorInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    compileError: (value: TraceApi.submission.CompileError) => Result;
    runtimeError: (value: TraceApi.submission.RuntimeError) => Result;
    internalError: (value: TraceApi.submission.InternalError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ErrorInfo = {
  compileError: (value: TraceApi.submission.CompileError): ErrorInfo.CompileError => {
    const valueWithoutVisit: Omit<ErrorInfo.CompileError, \\"_visit\\"> = {
      ...value,
      type: \\"compileError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.CompileError;
    castedValue._visit = (visitor) => visitor.compileError(value);
    return castedValue;
  },

  runtimeError: (value: TraceApi.submission.RuntimeError): ErrorInfo.RuntimeError => {
    const valueWithoutVisit: Omit<ErrorInfo.RuntimeError, \\"_visit\\"> = {
      ...value,
      type: \\"runtimeError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.RuntimeError;
    castedValue._visit = (visitor) => visitor.runtimeError(value);
    return castedValue;
  },

  internalError: (value: TraceApi.submission.InternalError): ErrorInfo.InternalError => {
    const valueWithoutVisit: Omit<ErrorInfo.InternalError, \\"_visit\\"> = {
      ...value,
      type: \\"internalError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.InternalError;
    castedValue._visit = (visitor) => visitor.internalError(value);
    return castedValue;
  },
} as const;
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ErroredResponse {
  submissionId: TraceApi.submission.SubmissionId;
  errorInfo: TraceApi.submission.ErrorInfo;
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExceptionInfo {
  exceptionType: string;
  exceptionMessage: string;
  exceptionStacktrace: string;
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ExceptionV2 = ExceptionV2.Generic | ExceptionV2.Timeout | ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
  interface Generic extends TraceApi.submission.ExceptionInfo, _Utils {
    type: \\"generic\\";
  }

  interface Timeout extends _Utils {
    type: \\"timeout\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ExceptionV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: TraceApi.submission.ExceptionInfo) => Result;
    timeout: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ExceptionV2 = {
  generic: (value: TraceApi.submission.ExceptionInfo): ExceptionV2.Generic => {
    const valueWithoutVisit: Omit<ExceptionV2.Generic, \\"_visit\\"> = {
      ...value,
      type: \\"generic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ExceptionV2.Generic;
    castedValue._visit = (visitor) => visitor.generic(value);
    return castedValue;
  },

  timeout: (): ExceptionV2.Timeout => {
    const valueWithoutVisit: Omit<ExceptionV2.Timeout, \\"_visit\\"> = {
      type: \\"timeout\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ExceptionV2.Timeout;
    castedValue._visit = (visitor) => visitor.timeout();
    return castedValue;
  },
} as const;
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExecutionSessionResponse {
  sessionId: string;
  executionSessionUrl?: string;
  language: TraceApi.commons.Language;
  status: TraceApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExecutionSessionState {
  lastTimeContacted?: string;
  sessionId: string;
  isWarmInstance: boolean;
  awsTaskId?: string;
  language: TraceApi.commons.Language;
  status: TraceApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExecutionSessionStatus<
  RawValue extends ExecutionSessionStatus.RawValue = ExecutionSessionStatus.RawValue
> {
  toString: () => RawValue;
  visit: <Result>(visitor: ExecutionSessionStatus._Visitor<Result>) => Result;
}

const _CreatingContainer: ExecutionSessionStatus<\\"CREATING_CONTAINER\\"> = {
  toString: () => \\"CREATING_CONTAINER\\",
  visit: (visitor) => visitor.creatingContainer(),
};
const _ProvisioningContainer: ExecutionSessionStatus<\\"PROVISIONING_CONTAINER\\"> = {
  toString: () => \\"PROVISIONING_CONTAINER\\",
  visit: (visitor) => visitor.provisioningContainer(),
};
const _PendingContainer: ExecutionSessionStatus<\\"PENDING_CONTAINER\\"> = {
  toString: () => \\"PENDING_CONTAINER\\",
  visit: (visitor) => visitor.pendingContainer(),
};
const _RunningContainer: ExecutionSessionStatus<\\"RUNNING_CONTAINER\\"> = {
  toString: () => \\"RUNNING_CONTAINER\\",
  visit: (visitor) => visitor.runningContainer(),
};
const _LiveContainer: ExecutionSessionStatus<\\"LIVE_CONTAINER\\"> = {
  toString: () => \\"LIVE_CONTAINER\\",
  visit: (visitor) => visitor.liveContainer(),
};
const _FailedToLaunch: ExecutionSessionStatus<\\"FAILED_TO_LAUNCH\\"> = {
  toString: () => \\"FAILED_TO_LAUNCH\\",
  visit: (visitor) => visitor.failedToLaunch(),
};
export const ExecutionSessionStatus = {
  CreatingContainer: _CreatingContainer,
  ProvisioningContainer: _ProvisioningContainer,
  PendingContainer: _PendingContainer,
  RunningContainer: _RunningContainer,
  LiveContainer: _LiveContainer,
  FailedToLaunch: _FailedToLaunch,
} as const;

export declare namespace ExecutionSessionStatus {
  type RawValue =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\"
    | string;

  interface _Visitor<Result> {
    creatingContainer: () => Result;
    provisioningContainer: () => Result;
    pendingContainer: () => Result;
    runningContainer: () => Result;
    liveContainer: () => Result;
    failedToLaunch: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExistingSubmissionExecuting {
  submissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExpressionLocation {
  start: number;
  offset: number;
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface FinishedResponse {
  submissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetExecutionSessionStateResponse {
  states: Record<string, TraceApi.submission.ExecutionSessionState>;
  numWarmingInstances?: number;
  warmingSessionIds: string[];
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetSubmissionStateResponse {
  timeSubmitted?: Date;
  submission: string;
  language: TraceApi.commons.Language;
  submissionTypeState: TraceApi.submission.SubmissionTypeState;
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GetTraceResponsesPageRequest {
  offset?: number;
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedResponse {
  submissionId: TraceApi.submission.SubmissionId;
  testCases: Record<string, TraceApi.submission.TestCaseResultWithStdout>;
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedResponseV2 {
  submissionId: TraceApi.submission.SubmissionId;
  testCases: Record<string, TraceApi.submission.TestCaseGrade>;
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedTestCaseUpdate {
  testCaseId: TraceApi.v2.problem.TestCaseId;
  grade: TraceApi.submission.TestCaseGrade;
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InitializeProblemRequest {
  problemId: TraceApi.commons.ProblemId;
  problemVersion?: number;
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InternalError {
  exceptionInfo: TraceApi.submission.ExceptionInfo;
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type InvalidRequestCause =
  /**
   * The submission request references a submission id that doesn't exist. */
  | InvalidRequestCause.SubmissionIdNotFound
  | InvalidRequestCause.CustomTestCasesUnsupported
  /**
   * The submission request was routed to an incorrect language executor. */
  | InvalidRequestCause.UnexpectedLanguage
  | InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
  interface SubmissionIdNotFound extends TraceApi.submission.SubmissionIdNotFound, _Utils {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends TraceApi.submission.CustomTestCasesUnsupported, _Utils {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends TraceApi.submission.UnexpectedLanguageError, _Utils {
    type: \\"unexpectedLanguage\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: InvalidRequestCause._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    submissionIdNotFound: (value: TraceApi.submission.SubmissionIdNotFound) => Result;
    customTestCasesUnsupported: (value: TraceApi.submission.CustomTestCasesUnsupported) => Result;
    unexpectedLanguage: (value: TraceApi.submission.UnexpectedLanguageError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const InvalidRequestCause = {
  submissionIdNotFound: (value: TraceApi.submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => {
    const valueWithoutVisit: Omit<InvalidRequestCause.SubmissionIdNotFound, \\"_visit\\"> = {
      ...value,
      type: \\"submissionIdNotFound\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.SubmissionIdNotFound;
    castedValue._visit = (visitor) => visitor.submissionIdNotFound(value);
    return castedValue;
  },

  customTestCasesUnsupported: (
    value: TraceApi.submission.CustomTestCasesUnsupported
  ): InvalidRequestCause.CustomTestCasesUnsupported => {
    const valueWithoutVisit: Omit<InvalidRequestCause.CustomTestCasesUnsupported, \\"_visit\\"> = {
      ...value,
      type: \\"customTestCasesUnsupported\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.CustomTestCasesUnsupported;
    castedValue._visit = (visitor) => visitor.customTestCasesUnsupported(value);
    return castedValue;
  },

  unexpectedLanguage: (value: TraceApi.submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => {
    const valueWithoutVisit: Omit<InvalidRequestCause.UnexpectedLanguage, \\"_visit\\"> = {
      ...value,
      type: \\"unexpectedLanguage\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.UnexpectedLanguage;
    castedValue._visit = (visitor) => visitor.unexpectedLanguage(value);
    return castedValue;
  },
} as const;
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InvalidRequestResponse {
  request: TraceApi.submission.SubmissionRequest;
  cause: TraceApi.submission.InvalidRequestCause;
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LightweightStackframeInformation {
  numStackFrames: number;
  topStackFrameMethodName: string;
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordedResponseNotification {
  submissionId: TraceApi.submission.SubmissionId;
  traceResponsesSize: number;
  testCaseId?: string;
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordedTestCaseUpdate {
  testCaseId: TraceApi.v2.problem.TestCaseId;
  traceResponsesSize: number;
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordingResponseNotification {
  submissionId: TraceApi.submission.SubmissionId;
  testCaseId?: string;
  lineNumber: number;
  lightweightStackInfo: TraceApi.submission.LightweightStackframeInformation;
  tracedFile?: TraceApi.submission.TracedFile;
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RunningResponse {
  submissionId: TraceApi.submission.SubmissionId;
  state: TraceApi.submission.RunningSubmissionState;
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface RunningSubmissionState<
  RawValue extends RunningSubmissionState.RawValue = RunningSubmissionState.RawValue
> {
  toString: () => RawValue;
  visit: <Result>(visitor: RunningSubmissionState._Visitor<Result>) => Result;
}

const _QueueingSubmission: RunningSubmissionState<\\"QUEUEING_SUBMISSION\\"> = {
  toString: () => \\"QUEUEING_SUBMISSION\\",
  visit: (visitor) => visitor.queueingSubmission(),
};
const _KillingHistoricalSubmissions: RunningSubmissionState<\\"KILLING_HISTORICAL_SUBMISSIONS\\"> = {
  toString: () => \\"KILLING_HISTORICAL_SUBMISSIONS\\",
  visit: (visitor) => visitor.killingHistoricalSubmissions(),
};
const _WritingSubmissionToFile: RunningSubmissionState<\\"WRITING_SUBMISSION_TO_FILE\\"> = {
  toString: () => \\"WRITING_SUBMISSION_TO_FILE\\",
  visit: (visitor) => visitor.writingSubmissionToFile(),
};
const _CompilingSubmission: RunningSubmissionState<\\"COMPILING_SUBMISSION\\"> = {
  toString: () => \\"COMPILING_SUBMISSION\\",
  visit: (visitor) => visitor.compilingSubmission(),
};
const _RunningSubmission: RunningSubmissionState<\\"RUNNING_SUBMISSION\\"> = {
  toString: () => \\"RUNNING_SUBMISSION\\",
  visit: (visitor) => visitor.runningSubmission(),
};
export const RunningSubmissionState = {
  QueueingSubmission: _QueueingSubmission,
  KillingHistoricalSubmissions: _KillingHistoricalSubmissions,
  WritingSubmissionToFile: _WritingSubmissionToFile,
  CompilingSubmission: _CompilingSubmission,
  RunningSubmission: _RunningSubmission,
} as const;

export declare namespace RunningSubmissionState {
  type RawValue =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\"
    | string;

  interface _Visitor<Result> {
    queueingSubmission: () => Result;
    killingHistoricalSubmissions: () => Result;
    writingSubmissionToFile: () => Result;
    compilingSubmission: () => Result;
    runningSubmission: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface RuntimeError {
  message: string;
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Scope {
  variables: Record<string, TraceApi.commons.DebugVariableValue>;
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ShareId = string;
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StackFrame {
  methodName: string;
  lineNumber: number;
  scopes: TraceApi.submission.Scope[];
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StackInformation {
  numStackFrames: number;
  topStackFrame?: TraceApi.submission.StackFrame;
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StderrResponse {
  submissionId: TraceApi.submission.SubmissionId;
  stderr: string;
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StdoutResponse {
  submissionId: TraceApi.submission.SubmissionId;
  stdout: string;
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StopRequest {
  submissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoppedResponse {
  submissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface SubmissionFileInfo {
  directory: string;
  filename: string;
  contents: string;
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type SubmissionId = string;
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SubmissionIdNotFound {
  missingSubmissionId: TraceApi.submission.SubmissionId;
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionRequest =
  | SubmissionRequest.InitializeProblemRequest
  | SubmissionRequest.InitializeWorkspaceRequest
  | SubmissionRequest.SubmitV2
  | SubmissionRequest.WorkspaceSubmit
  | SubmissionRequest.Stop
  | SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
  interface InitializeProblemRequest extends TraceApi.submission.InitializeProblemRequest, _Utils {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest extends _Utils {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends TraceApi.submission.SubmitRequestV2, _Utils {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends TraceApi.submission.WorkspaceSubmitRequest, _Utils {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends TraceApi.submission.StopRequest, _Utils {
    type: \\"stop\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionRequest._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    initializeProblemRequest: (value: TraceApi.submission.InitializeProblemRequest) => Result;
    initializeWorkspaceRequest: () => Result;
    submitV2: (value: TraceApi.submission.SubmitRequestV2) => Result;
    workspaceSubmit: (value: TraceApi.submission.WorkspaceSubmitRequest) => Result;
    stop: (value: TraceApi.submission.StopRequest) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionRequest = {
  initializeProblemRequest: (
    value: TraceApi.submission.InitializeProblemRequest
  ): SubmissionRequest.InitializeProblemRequest => {
    const valueWithoutVisit: Omit<SubmissionRequest.InitializeProblemRequest, \\"_visit\\"> = {
      ...value,
      type: \\"initializeProblemRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.InitializeProblemRequest;
    castedValue._visit = (visitor) => visitor.initializeProblemRequest(value);
    return castedValue;
  },

  initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => {
    const valueWithoutVisit: Omit<SubmissionRequest.InitializeWorkspaceRequest, \\"_visit\\"> = {
      type: \\"initializeWorkspaceRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.InitializeWorkspaceRequest;
    castedValue._visit = (visitor) => visitor.initializeWorkspaceRequest();
    return castedValue;
  },

  submitV2: (value: TraceApi.submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => {
    const valueWithoutVisit: Omit<SubmissionRequest.SubmitV2, \\"_visit\\"> = {
      ...value,
      type: \\"submitV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.SubmitV2;
    castedValue._visit = (visitor) => visitor.submitV2(value);
    return castedValue;
  },

  workspaceSubmit: (value: TraceApi.submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => {
    const valueWithoutVisit: Omit<SubmissionRequest.WorkspaceSubmit, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceSubmit\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.WorkspaceSubmit;
    castedValue._visit = (visitor) => visitor.workspaceSubmit(value);
    return castedValue;
  },

  stop: (value: TraceApi.submission.StopRequest): SubmissionRequest.Stop => {
    const valueWithoutVisit: Omit<SubmissionRequest.Stop, \\"_visit\\"> = {
      ...value,
      type: \\"stop\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.Stop;
    castedValue._visit = (visitor) => visitor.stop(value);
    return castedValue;
  },
} as const;
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionResponse =
  | SubmissionResponse.ServerInitialized
  | SubmissionResponse.ProblemInitialized
  | SubmissionResponse.WorkspaceInitialized
  | SubmissionResponse.ServerErrored
  | SubmissionResponse.CodeExecutionUpdate
  | SubmissionResponse.Terminated
  | SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
  interface ServerInitialized extends _Utils {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized extends _Utils {
    type: \\"problemInitialized\\";
    value: TraceApi.commons.ProblemId;
  }

  interface WorkspaceInitialized extends _Utils {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends TraceApi.submission.ExceptionInfo, _Utils {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate extends _Utils {
    type: \\"codeExecutionUpdate\\";
    value: TraceApi.submission.CodeExecutionUpdate;
  }

  interface Terminated extends TraceApi.submission.TerminatedResponse, _Utils {
    type: \\"terminated\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    serverInitialized: () => Result;
    problemInitialized: (value: TraceApi.commons.ProblemId) => Result;
    workspaceInitialized: () => Result;
    serverErrored: (value: TraceApi.submission.ExceptionInfo) => Result;
    codeExecutionUpdate: (value: TraceApi.submission.CodeExecutionUpdate) => Result;
    terminated: (value: TraceApi.submission.TerminatedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionResponse = {
  serverInitialized: (): SubmissionResponse.ServerInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.ServerInitialized, \\"_visit\\"> = {
      type: \\"serverInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ServerInitialized;
    castedValue._visit = (visitor) => visitor.serverInitialized();
    return castedValue;
  },

  problemInitialized: (value: TraceApi.commons.ProblemId): SubmissionResponse.ProblemInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.ProblemInitialized, \\"_visit\\"> = {
      value: value,
      type: \\"problemInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ProblemInitialized;
    castedValue._visit = (visitor) => visitor.problemInitialized(value);
    return castedValue;
  },

  workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.WorkspaceInitialized, \\"_visit\\"> = {
      type: \\"workspaceInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.WorkspaceInitialized;
    castedValue._visit = (visitor) => visitor.workspaceInitialized();
    return castedValue;
  },

  serverErrored: (value: TraceApi.submission.ExceptionInfo): SubmissionResponse.ServerErrored => {
    const valueWithoutVisit: Omit<SubmissionResponse.ServerErrored, \\"_visit\\"> = {
      ...value,
      type: \\"serverErrored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ServerErrored;
    castedValue._visit = (visitor) => visitor.serverErrored(value);
    return castedValue;
  },

  codeExecutionUpdate: (value: TraceApi.submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => {
    const valueWithoutVisit: Omit<SubmissionResponse.CodeExecutionUpdate, \\"_visit\\"> = {
      value: value,
      type: \\"codeExecutionUpdate\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.CodeExecutionUpdate;
    castedValue._visit = (visitor) => visitor.codeExecutionUpdate(value);
    return castedValue;
  },

  terminated: (value: TraceApi.submission.TerminatedResponse): SubmissionResponse.Terminated => {
    const valueWithoutVisit: Omit<SubmissionResponse.Terminated, \\"_visit\\"> = {
      ...value,
      type: \\"terminated\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.Terminated;
    castedValue._visit = (visitor) => visitor.terminated(value);
    return castedValue;
  },
} as const;
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionStatusForTestCase =
  | SubmissionStatusForTestCase.Graded
  | SubmissionStatusForTestCase.GradedV2
  | SubmissionStatusForTestCase.Traced
  | SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
  interface Graded extends TraceApi.submission.TestCaseResultWithStdout, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends _Utils {
    type: \\"gradedV2\\";
    value: TraceApi.submission.TestCaseGrade;
  }

  interface Traced extends TraceApi.submission.TracedTestCase, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionStatusForTestCase._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    graded: (value: TraceApi.submission.TestCaseResultWithStdout) => Result;
    gradedV2: (value: TraceApi.submission.TestCaseGrade) => Result;
    traced: (value: TraceApi.submission.TracedTestCase) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusForTestCase = {
  graded: (value: TraceApi.submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.Graded;
    castedValue._visit = (visitor) => visitor.graded(value);
    return castedValue;
  },

  gradedV2: (value: TraceApi.submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.GradedV2, \\"_visit\\"> = {
      value: value,
      type: \\"gradedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.GradedV2;
    castedValue._visit = (visitor) => visitor.gradedV2(value);
    return castedValue;
  },

  traced: (value: TraceApi.submission.TracedTestCase): SubmissionStatusForTestCase.Traced => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.Traced;
    castedValue._visit = (visitor) => visitor.traced(value);
    return castedValue;
  },
} as const;
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionStatusV2 = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace | SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
  interface Test extends TraceApi.submission.TestSubmissionStatusV2, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.submission.WorkspaceSubmissionStatusV2, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionStatusV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: TraceApi.submission.TestSubmissionStatusV2) => Result;
    workspace: (value: TraceApi.submission.WorkspaceSubmissionStatusV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusV2 = {
  test: (value: TraceApi.submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => {
    const valueWithoutVisit: Omit<SubmissionStatusV2.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusV2.Test;
    castedValue._visit = (visitor) => visitor.test(value);
    return castedValue;
  },

  workspace: (value: TraceApi.submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => {
    const valueWithoutVisit: Omit<SubmissionStatusV2.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusV2.Workspace;
    castedValue._visit = (visitor) => visitor.workspace(value);
    return castedValue;
  },
} as const;
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

/**
 * Keep in sync with SubmissionType.
 */
export interface SubmissionTypeEnum<RawValue extends SubmissionTypeEnum.RawValue = SubmissionTypeEnum.RawValue> {
  toString: () => RawValue;
  visit: <Result>(visitor: SubmissionTypeEnum._Visitor<Result>) => Result;
}

const _Test: SubmissionTypeEnum<\\"TEST\\"> = {
  toString: () => \\"TEST\\",
  visit: (visitor) => visitor.test(),
};
export const SubmissionTypeEnum = {
  Test: _Test,
} as const;

export declare namespace SubmissionTypeEnum {
  type RawValue = \\"TEST\\" | string;

  interface _Visitor<Result> {
    test: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionTypeState =
  | SubmissionTypeState.Test
  | SubmissionTypeState.Workspace
  | SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
  interface Test extends TraceApi.submission.TestSubmissionState, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.submission.WorkspaceSubmissionState, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionTypeState._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: TraceApi.submission.TestSubmissionState) => Result;
    workspace: (value: TraceApi.submission.WorkspaceSubmissionState) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionTypeState = {
  test: (value: TraceApi.submission.TestSubmissionState): SubmissionTypeState.Test => {
    const valueWithoutVisit: Omit<SubmissionTypeState.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionTypeState.Test;
    castedValue._visit = (visitor) => visitor.test(value);
    return castedValue;
  },

  workspace: (value: TraceApi.submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => {
    const valueWithoutVisit: Omit<SubmissionTypeState.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionTypeState.Workspace;
    castedValue._visit = (visitor) => visitor.workspace(value);
    return castedValue;
  },
} as const;
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SubmitRequestV2 {
  submissionId: TraceApi.submission.SubmissionId;
  language: TraceApi.commons.Language;
  submissionFiles: TraceApi.submission.SubmissionFileInfo[];
  problemId: TraceApi.commons.ProblemId;
  problemVersion?: number;
  userId?: string;
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TerminatedResponse {}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type TestCaseGrade = TestCaseGrade.Hidden | TestCaseGrade.NonHidden | TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
  interface Hidden extends TraceApi.submission.TestCaseHiddenGrade, _Utils {
    type: \\"hidden\\";
  }

  interface NonHidden extends TraceApi.submission.TestCaseNonHiddenGrade, _Utils {
    type: \\"nonHidden\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseGrade._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    hidden: (value: TraceApi.submission.TestCaseHiddenGrade) => Result;
    nonHidden: (value: TraceApi.submission.TestCaseNonHiddenGrade) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseGrade = {
  hidden: (value: TraceApi.submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => {
    const valueWithoutVisit: Omit<TestCaseGrade.Hidden, \\"_visit\\"> = {
      ...value,
      type: \\"hidden\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseGrade.Hidden;
    castedValue._visit = (visitor) => visitor.hidden(value);
    return castedValue;
  },

  nonHidden: (value: TraceApi.submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => {
    const valueWithoutVisit: Omit<TestCaseGrade.NonHidden, \\"_visit\\"> = {
      ...value,
      type: \\"nonHidden\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseGrade.NonHidden;
    castedValue._visit = (visitor) => visitor.nonHidden(value);
    return castedValue;
  },
} as const;
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseHiddenGrade {
  passed: boolean;
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseNonHiddenGrade {
  passed: boolean;
  actualResult?: TraceApi.commons.VariableValue;
  exception?: TraceApi.submission.ExceptionV2;
  stdout: string;
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseResult {
  expectedResult: TraceApi.commons.VariableValue;
  actualResult: TraceApi.submission.ActualResult;
  passed: boolean;
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseResultWithStdout {
  result: TraceApi.submission.TestCaseResult;
  stdout: string;
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionState {
  problemId: TraceApi.commons.ProblemId;
  defaultTestCases: TraceApi.commons.TestCase[];
  customTestCases: TraceApi.commons.TestCase[];
  status: TraceApi.submission.TestSubmissionStatus;
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type TestSubmissionStatus =
  | TestSubmissionStatus.Stopped
  | TestSubmissionStatus.Errored
  | TestSubmissionStatus.Running
  | TestSubmissionStatus.TestCaseIdToState
  | TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.submission.RunningSubmissionState;
  }

  interface TestCaseIdToState extends _Utils {
    type: \\"testCaseIdToState\\";
    value: Record<string, TraceApi.submission.SubmissionStatusForTestCase>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestSubmissionStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: TraceApi.submission.ErrorInfo) => Result;
    running: (value: TraceApi.submission.RunningSubmissionState) => Result;
    testCaseIdToState: (value: Record<string, TraceApi.submission.SubmissionStatusForTestCase>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionStatus = {
  stopped: (): TestSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceApi.submission.ErrorInfo): TestSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  running: (value: TraceApi.submission.RunningSubmissionState): TestSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  testCaseIdToState: (
    value: Record<string, TraceApi.submission.SubmissionStatusForTestCase>
  ): TestSubmissionStatus.TestCaseIdToState => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.TestCaseIdToState, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseIdToState\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.TestCaseIdToState;
    castedValue._visit = (visitor) => visitor.testCaseIdToState(value);
    return castedValue;
  },
} as const;
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionStatusV2 {
  updates: TraceApi.submission.TestSubmissionUpdate[];
  problemId: TraceApi.commons.ProblemId;
  problemVersion: number;
  problemInfo: TraceApi.v2.problem.ProblemInfoV2;
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.submission.TestSubmissionUpdateInfo;
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type TestSubmissionUpdateInfo =
  | TestSubmissionUpdateInfo.Running
  | TestSubmissionUpdateInfo.Stopped
  | TestSubmissionUpdateInfo.Errored
  | TestSubmissionUpdateInfo.GradedTestCase
  | TestSubmissionUpdateInfo.RecordedTestCase
  | TestSubmissionUpdateInfo.Finished
  | TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.submission.RunningSubmissionState;
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.submission.ErrorInfo;
  }

  interface GradedTestCase extends TraceApi.submission.GradedTestCaseUpdate, _Utils {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends TraceApi.submission.RecordedTestCaseUpdate, _Utils {
    type: \\"recordedTestCase\\";
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestSubmissionUpdateInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    running: (value: TraceApi.submission.RunningSubmissionState) => Result;
    stopped: () => Result;
    errored: (value: TraceApi.submission.ErrorInfo) => Result;
    gradedTestCase: (value: TraceApi.submission.GradedTestCaseUpdate) => Result;
    recordedTestCase: (value: TraceApi.submission.RecordedTestCaseUpdate) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionUpdateInfo = {
  running: (value: TraceApi.submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  stopped: (): TestSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceApi.submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  gradedTestCase: (value: TraceApi.submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.GradedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"gradedTestCase\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.GradedTestCase;
    castedValue._visit = (visitor) => visitor.gradedTestCase(value);
    return castedValue;
  },

  recordedTestCase: (value: TraceApi.submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.RecordedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"recordedTestCase\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.RecordedTestCase;
    castedValue._visit = (visitor) => visitor.recordedTestCase(value);
    return castedValue;
  },

  finished: (): TestSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Finished;
    castedValue._visit = (visitor) => visitor.finished();
    return castedValue;
  },
} as const;
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponse {
  submissionId: TraceApi.submission.SubmissionId;
  lineNumber: number;
  returnValue?: TraceApi.commons.DebugVariableValue;
  expressionLocation?: TraceApi.submission.ExpressionLocation;
  stack: TraceApi.submission.StackInformation;
  stdout?: string;
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponseV2 {
  submissionId: TraceApi.submission.SubmissionId;
  lineNumber: number;
  file: TraceApi.submission.TracedFile;
  returnValue?: TraceApi.commons.DebugVariableValue;
  expressionLocation?: TraceApi.submission.ExpressionLocation;
  stack: TraceApi.submission.StackInformation;
  stdout?: string;
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponsesPage {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.submission.TraceResponse[];
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponsesPageV2 {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.submission.TraceResponseV2[];
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TracedFile {
  filename: string;
  directory: string;
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TracedTestCase {
  result: TraceApi.submission.TestCaseResultWithStdout;
  traceResponsesSize: number;
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface UnexpectedLanguageError {
  expectedLanguage: TraceApi.commons.Language;
  actualLanguage: TraceApi.commons.Language;
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceFiles {
  mainFile: TraceApi.commons.FileInfo;
  readOnlyFiles: TraceApi.commons.FileInfo[];
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceRanResponse {
  submissionId: TraceApi.submission.SubmissionId;
  runDetails: TraceApi.submission.WorkspaceRunDetails;
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceRunDetails {
  exceptionV2?: TraceApi.submission.ExceptionV2;
  exception?: TraceApi.submission.ExceptionInfo;
  stdout: string;
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponse {
  files: Record<TraceApi.commons.Language.RawValue, TraceApi.submission.WorkspaceFiles>;
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponseV2 {
  filesByLanguage: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionState {
  status: TraceApi.submission.WorkspaceSubmissionStatus;
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type WorkspaceSubmissionStatus =
  | WorkspaceSubmissionStatus.Stopped
  | WorkspaceSubmissionStatus.Errored
  | WorkspaceSubmissionStatus.Running
  | WorkspaceSubmissionStatus.Ran
  | WorkspaceSubmissionStatus.Traced
  | WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.submission.RunningSubmissionState;
  }

  interface Ran extends TraceApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Traced extends TraceApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: WorkspaceSubmissionStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: TraceApi.submission.ErrorInfo) => Result;
    running: (value: TraceApi.submission.RunningSubmissionState) => Result;
    ran: (value: TraceApi.submission.WorkspaceRunDetails) => Result;
    traced: (value: TraceApi.submission.WorkspaceRunDetails) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionStatus = {
  stopped: (): WorkspaceSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceApi.submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  running: (value: TraceApi.submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  ran: (value: TraceApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Ran;
    castedValue._visit = (visitor) => visitor.ran(value);
    return castedValue;
  },

  traced: (value: TraceApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Traced;
    castedValue._visit = (visitor) => visitor.traced(value);
    return castedValue;
  },
} as const;
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionStatusV2 {
  updates: TraceApi.submission.WorkspaceSubmissionUpdate[];
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.submission.WorkspaceSubmissionUpdateInfo;
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type WorkspaceSubmissionUpdateInfo =
  | WorkspaceSubmissionUpdateInfo.Running
  | WorkspaceSubmissionUpdateInfo.Ran
  | WorkspaceSubmissionUpdateInfo.Stopped
  | WorkspaceSubmissionUpdateInfo.Traced
  | WorkspaceSubmissionUpdateInfo.TracedV2
  | WorkspaceSubmissionUpdateInfo.Errored
  | WorkspaceSubmissionUpdateInfo.Finished
  | WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.submission.RunningSubmissionState;
  }

  interface Ran extends TraceApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Traced extends _Utils {
    type: \\"traced\\";
  }

  interface TracedV2 extends TraceApi.submission.WorkspaceTracedUpdate, _Utils {
    type: \\"tracedV2\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.submission.ErrorInfo;
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    running: (value: TraceApi.submission.RunningSubmissionState) => Result;
    ran: (value: TraceApi.submission.WorkspaceRunDetails) => Result;
    stopped: () => Result;
    traced: () => Result;
    tracedV2: (value: TraceApi.submission.WorkspaceTracedUpdate) => Result;
    errored: (value: TraceApi.submission.ErrorInfo) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionUpdateInfo = {
  running: (value: TraceApi.submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  ran: (value: TraceApi.submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Ran;
    castedValue._visit = (visitor) => visitor.ran(value);
    return castedValue;
  },

  stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  traced: (): WorkspaceSubmissionUpdateInfo.Traced => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Traced, \\"_visit\\"> = {
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Traced;
    castedValue._visit = (visitor) => visitor.traced();
    return castedValue;
  },

  tracedV2: (value: TraceApi.submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.TracedV2, \\"_visit\\"> = {
      ...value,
      type: \\"tracedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.TracedV2;
    castedValue._visit = (visitor) => visitor.tracedV2(value);
    return castedValue;
  },

  errored: (value: TraceApi.submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  finished: (): WorkspaceSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Finished;
    castedValue._visit = (visitor) => visitor.finished();
    return castedValue;
  },
} as const;
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmitRequest {
  submissionId: TraceApi.submission.SubmissionId;
  language: TraceApi.commons.Language;
  submissionFiles: TraceApi.submission.SubmissionFileInfo[];
  userId?: string;
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface WorkspaceTracedUpdate {
  traceResponsesSize: number;
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  setNumWarmInstances(
    request: TraceApi.sysprop.setNumWarmInstances.Request
  ): Promise<TraceApi.sysprop.setNumWarmInstances.Response>;
  getNumWarmInstances(): Promise<TraceApi.sysprop.getNumWarmInstances.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    request: TraceApi.sysprop.setNumWarmInstances.Request
  ): Promise<TraceApi.sysprop.setNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sysprop/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`),
      method: \\"PUT\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getNumWarmInstances(): Promise<TraceApi.sysprop.getNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.sysprop.getNumWarmInstances.Response.parse(
          response.body as Record<schemas.commons.Language.Raw, number>
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<TraceApi.commons.Language.RawValue, number>,
  TraceApi.sysprop.getNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  language: TraceApi.commons.Language;
  numWarmInstances: number;
}

export type Response = core.APIResponse<void, TraceApi.sysprop.setNumWarmInstances.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setNumWarmInstances.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";
import { Wrapper as V3Wrapper } from \\"./v3/Wrapper\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v3: V3Wrapper | undefined;

  public get v3(): V3Wrapper {
    return (this.#v3 ??= new V3Wrapper(this.options));
  }
}
",
            "name": "Wrapper.ts",
            "type": "file",
          },
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { TraceApi } from \\"../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<TraceApi.v2.problem.getLightweightProblems.Response>;
  getProblems(): Promise<TraceApi.v2.problem.getProblems.Response>;
  getLatestProblem(
    request: TraceApi.v2.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: TraceApi.v2.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceApi.v2.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getProblems.Response.parse(response.body as schemas.v2.problem.ProblemInfoV2.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceApi.v2.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/problems-v2/problem-info/\${request.problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(response.body as schemas.v2.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceApi.v2.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(response.body as schemas.v2.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { TraceApi } from \\"../../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
}

export type Response = core.APIResponse<TraceApi.v2.problem.ProblemInfoV2, TraceApi.v2.problem.getLatestProblem.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLatestProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.problem.LightweightProblemInfoV2[],
  TraceApi.v2.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { TraceApi } from \\"../../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<TraceApi.v2.problem.ProblemInfoV2, TraceApi.v2.problem.getProblemVersion.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblemVersion.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.problem.ProblemInfoV2[], TraceApi.v2.problem.getProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.problem.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (value: TraceApi.v2.problem.DeepEqualityCorrectnessCheck) => Result;
    custom: (value: TraceApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceApi.v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.DeepEquality;
    castedValue._visit = (visitor) => visitor.deepEquality(value);
    return castedValue;
  },

  custom: (value: TraceApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.problem.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
  basicTestCaseTemplate: TraceApi.v2.problem.BasicTestCaseTemplate;
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.problem.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.problem.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.problem.ParameterId;
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.problem.ProblemDescription;
  customFiles: TraceApi.v2.problem.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.problem.TestCaseTemplate[];
  testcases: TraceApi.v2.problem.TestCaseV2[];
  supportedLanguages: TraceApi.commons.Language[];
  isPublic: boolean;
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type CustomFiles = CustomFiles.Basic | CustomFiles.Custom | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: TraceApi.v2.problem.BasicCustomFiles) => Result;
    custom: (value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.problem.BasicCustomFiles): CustomFiles.Basic => {
    const valueWithoutVisit: Omit<CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Basic;
    castedValue._visit = (visitor) => visitor.basic(value);
    return castedValue;
  },

  custom: (value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>): CustomFiles.Custom => {
    const valueWithoutVisit: Omit<CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.problem.ParameterId;
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.problem.FileInfoV2;
  relatedTypes: TraceApi.commons.VariableType[];
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface Files {
  files: TraceApi.v2.problem.FileInfoV2[];
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.FunctionImplementation>;
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.problem.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceApi.v2.problem.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: TraceApi.v2.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: TraceApi.v2.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (value: TraceApi.v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.problem.VoidFunctionSignature): FunctionSignature.Void => {
    const valueWithoutVisit: Omit<FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.Void;
    castedValue._visit = (visitor) => visitor.void(value);
    return castedValue;
  },

  nonVoid: (value: TraceApi.v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.NonVoid;
    castedValue._visit = (visitor) => visitor.nonVoid(value);
    return castedValue;
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.VoidThatTakesActualResult;
    castedValue._visit = (visitor) => visitor.voidThatTakesActualResult(value);
    return castedValue;
  },
} as const;
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
  generatedTemplateFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
  other: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.Files>;
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.problem.NonVoidFunctionSignature;
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.problem.FileInfoV2>;
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.problem.FunctionSignature;
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.commons.Language.RawValue, string>;
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.problem.TestCaseTemplate;
  testCase: TraceApi.v2.problem.TestCaseV2;
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.problem.TestCaseTemplate;
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.commons.VariableType[];
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.problem.NonVoidFunctionSignature;
  code: TraceApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.problem.Parameter[];
  returnType: TraceApi.commons.VariableType;
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface Parameter {
  parameterId: TraceApi.v2.problem.ParameterId;
  name: string;
  variableType: TraceApi.commons.VariableType;
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ParameterId = string;
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.commons.ProblemId;
  problemDescription: TraceApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.commons.Language[];
  customFiles: TraceApi.v2.problem.CustomFiles;
  generatedFiles: TraceApi.v2.problem.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.problem.TestCaseTemplate[];
  testcases: TraceApi.v2.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type TestCaseFunction = TestCaseFunction.WithActualResult | TestCaseFunction.Custom | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.problem.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (value: TraceApi.v2.problem.TestCaseWithActualResultImplementation) => Result;
    custom: (value: TraceApi.v2.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.WithActualResult;
    castedValue._visit = (visitor) => visitor.withActualResult(value);
    return castedValue;
  },

  custom: (value: TraceApi.v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseId = string;
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.problem.TestCaseImplementationDescription;
  function: TraceApi.v2.problem.TestCaseFunction;
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: TraceApi.v2.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  paramId: (value: TraceApi.v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.ParamId;
    castedValue._visit = (visitor) => visitor.paramId(value);
    return castedValue;
  },
} as const;
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.problem.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.problem.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: TraceApi.v2.problem.TestCaseTemplateId) => Result;
    implementation: (value: TraceApi.v2.problem.TestCaseImplementation) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.TemplateId;
    castedValue._visit = (visitor) => visitor.templateId(value);
    return castedValue;
  },

  implementation: (
    value: TraceApi.v2.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.Implementation;
    castedValue._visit = (visitor) => visitor.implementation(value);
    return castedValue;
  },
} as const;
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.problem.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.problem.TestCaseImplementation;
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseTemplateId = string;
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.problem.TestCaseMetadata;
  implementation: TraceApi.v2.problem.TestCaseImplementationReference;
  arguments: Record<string, TraceApi.commons.VariableValue>;
  expects?: TraceApi.v2.problem.TestCaseExpects;
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.problem.AssertCorrectnessCheck;
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.problem.Parameter[];
  code: TraceApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.problem.Parameter[];
  code: TraceApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.problem.Parameter[];
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.problem.Parameter[];
  actualResultType: TraceApi.commons.VariableType;
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }
}
",
                "name": "Wrapper.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<TraceApi.v2.v3.problem.getLightweightProblems.Response>;
  getProblems(): Promise<TraceApi.v2.v3.problem.getProblems.Response>;
  getLatestProblem(
    request: TraceApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.v3.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: TraceApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.v3.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.Supplier<core.BearerToken>;
    _credentials?: core.Supplier<core.BasicAuth>;
    xApiKey?: core.Supplier<string>;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.v3.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceApi.v2.v3.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getProblems.Response.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.v3.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/problems-v2/problem-info/\${request.problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.v3.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options._token)) ??
          core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options._credentials)),
        \\"X-API-Key\\": await core.Supplier.get(this.options.xApiKey),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  TraceApi.v2.v3.problem.ProblemInfoV2,
  TraceApi.v2.v3.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLatestProblem.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.v3.problem.LightweightProblemInfoV2[],
  TraceApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.Supplier<core.BearerToken>;
  _credentials?: core.Supplier<core.BasicAuth>;
  xApiKey?: core.Supplier<string>;
  problemId: TraceApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  TraceApi.v2.v3.problem.ProblemInfoV2,
  TraceApi.v2.v3.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblemVersion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.v3.problem.ProblemInfoV2[],
  TraceApi.v2.v3.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.v3.problem.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (value: TraceApi.v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
    custom: (value: TraceApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceApi.v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.DeepEquality;
    castedValue._visit = (visitor) => visitor.deepEquality(value);
    return castedValue;
  },

  custom: (
    value: TraceApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
  ): AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.v3.problem.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>;
  basicTestCaseTemplate: TraceApi.v2.v3.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.v3.problem.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.v3.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.problem.ProblemDescription;
  customFiles: TraceApi.v2.v3.problem.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.v3.problem.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.problem.TestCaseV2[];
  supportedLanguages: TraceApi.commons.Language[];
  isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type CustomFiles = CustomFiles.Basic | CustomFiles.Custom | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.v3.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: TraceApi.v2.v3.problem.BasicCustomFiles) => Result;
    custom: (value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => {
    const valueWithoutVisit: Omit<CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Basic;
    castedValue._visit = (visitor) => visitor.basic(value);
    return castedValue;
  },

  custom: (value: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>): CustomFiles.Custom => {
    const valueWithoutVisit: Omit<CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.v3.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.v3.problem.FileInfoV2;
  relatedTypes: TraceApi.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface Files {
  files: TraceApi.v2.v3.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.v3.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.v3.problem.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends TraceApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult,
      _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: TraceApi.v2.v3.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: TraceApi.v2.v3.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (value: TraceApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => {
    const valueWithoutVisit: Omit<FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.Void;
    castedValue._visit = (visitor) => visitor.void(value);
    return castedValue;
  },

  nonVoid: (value: TraceApi.v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.NonVoid;
    castedValue._visit = (visitor) => visitor.nonVoid(value);
    return castedValue;
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.VoidThatTakesActualResult;
    castedValue._visit = (visitor) => visitor.voidThatTakesActualResult(value);
    return castedValue;
  },
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>;
  generatedTemplateFiles: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>;
  other: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.v3.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.commons.Language.RawValue, TraceApi.v2.v3.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.v3.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.commons.Language.RawValue, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.v3.problem.TestCaseTemplate;
  testCase: TraceApi.v2.v3.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.v3.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.v3.problem.NonVoidFunctionSignature;
  code: TraceApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.v3.problem.Parameter[];
  returnType: TraceApi.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface Parameter {
  parameterId: TraceApi.v2.v3.problem.ParameterId;
  name: string;
  variableType: TraceApi.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.commons.ProblemId;
  problemDescription: TraceApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.commons.Language[];
  customFiles: TraceApi.v2.v3.problem.CustomFiles;
  generatedFiles: TraceApi.v2.v3.problem.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.v3.problem.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type TestCaseFunction = TestCaseFunction.WithActualResult | TestCaseFunction.Custom | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.v3.problem.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.v3.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (value: TraceApi.v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
    custom: (value: TraceApi.v2.v3.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.v3.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.WithActualResult;
    castedValue._visit = (visitor) => visitor.withActualResult(value);
    return castedValue;
  },

  custom: (value: TraceApi.v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.v3.problem.TestCaseImplementationDescription;
  function: TraceApi.v2.v3.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.v3.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: TraceApi.v2.v3.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  paramId: (value: TraceApi.v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.ParamId;
    castedValue._visit = (visitor) => visitor.paramId(value);
    return castedValue;
  },
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.v3.problem.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.v3.problem.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: TraceApi.v2.v3.problem.TestCaseTemplateId) => Result;
    implementation: (value: TraceApi.v2.v3.problem.TestCaseImplementation) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.TemplateId;
    castedValue._visit = (visitor) => visitor.templateId(value);
    return castedValue;
  },

  implementation: (
    value: TraceApi.v2.v3.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.Implementation;
    castedValue._visit = (visitor) => visitor.implementation(value);
    return castedValue;
  },
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.v3.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.v3.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.v3.problem.TestCaseMetadata;
  implementation: TraceApi.v2.v3.problem.TestCaseImplementationReference;
  arguments: Record<string, TraceApi.commons.VariableValue>;
  expects?: TraceApi.v2.v3.problem.TestCaseExpects;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.v3.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.v3.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.v3.problem.Parameter[];
  code: TraceApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.v3.problem.Parameter[];
  code: TraceApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.v3.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.v3.problem.Parameter[];
  actualResultType: TraceApi.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
    if (basicAuth == null) {
      return undefined;
    }
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
            "name": "BasicAuth.ts",
            "type": "file",
          },
          Object {
            "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
    if (token == null) {
      return undefined;
    }
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
            "name": "BearerToken.ts",
            "type": "file",
          },
          Object {
            "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "auth",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
            "name": "APIResponse.ts",
            "type": "file",
          },
          Object {
            "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
            "name": "Fetcher.ts",
            "type": "file",
          },
          Object {
            "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
            "name": "Supplier.ts",
            "type": "file",
          },
          Object {
            "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "fetcher",
        "type": "directory",
      },
      Object {
        "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./auth\\";
export * from \\"./fetcher\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
            "name": "Schema.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "date.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                    "name": "enum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "identity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "identity",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                    "name": "lazy.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                    "name": "lazyObject.ts",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "list.ts",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                    "name": "stringLiteral.ts",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                    "name": "object.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                    "name": "property.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                    "name": "getObjectLikeUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                    "name": "withProperties.ts",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                    "name": "any.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                    "name": "boolean.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                    "name": "number.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                    "name": "string.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                    "name": "unknown.ts",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "record.ts",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "getSchemaUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "set.ts",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                    "name": "union.ts",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.ts",
                "type": "file",
              },
              Object {
                "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                "name": "entries.ts",
                "type": "file",
              },
              Object {
                "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                "name": "keys.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as TraceApi from \\"./api\\";
",
    "name": "index.ts",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/api-sdk\\",
    \\"version\\": \\"\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"files\\": [
        \\"/api/**/*.{js,js.map,d.ts}\\",
        \\"/schemas/**/*.{js,js.map,d.ts}\\",
        \\"/core/**/*.{js,js.map,d.ts}\\",
        \\"/index.{js,js.map,d.ts}\\"
    ],
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 '**/*.ts'\\",
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"peerDependencies\\": {
        \\"axios\\": \\"*\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  TraceApi.submission.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponseV2));
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  TraceApi.submission.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponseV2));
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoreTracedTestCaseRequest: core.schemas.ObjectSchema<
  StoreTracedTestCaseRequest.Raw,
  TraceApi.admin.StoreTracedTestCaseRequest
> = core.schemas.object({
  result: core.schemas.lazyObject(() => schemas.submission.TestCaseResultWithStdout),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponse)),
});

export declare namespace StoreTracedTestCaseRequest {
  interface Raw {
    result: schemas.submission.TestCaseResultWithStdout.Raw;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoreTracedWorkspaceRequest: core.schemas.ObjectSchema<
  StoreTracedWorkspaceRequest.Raw,
  TraceApi.admin.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponse)),
});

export declare namespace StoreTracedWorkspaceRequest {
  interface Raw {
    workspaceRunDetails: schemas.submission.WorkspaceRunDetails.Raw;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeAndTreeValue.Raw,
  TraceApi.commons.BinaryTreeNodeAndTreeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullTree: core.schemas.lazyObject(() => schemas.commons.BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullTree: schemas.commons.BinaryTreeValue.Raw;
  }
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeValue.Raw,
  TraceApi.commons.BinaryTreeNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  right: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  left: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace BinaryTreeNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    right?: schemas.commons.NodeId.Raw | null;
    left?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<BinaryTreeValue.Raw, TraceApi.commons.BinaryTreeValue> =
  core.schemas.object({
    root: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
    nodes: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.commons.BinaryTreeNodeValue)
    ),
  });

export declare namespace BinaryTreeValue {
  interface Raw {
    root?: schemas.commons.NodeId.Raw | null;
    nodes: Record<schemas.commons.NodeId.Raw, schemas.commons.BinaryTreeNodeValue.Raw>;
  }
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<
  DebugKeyValuePairs.Raw,
  TraceApi.commons.DebugKeyValuePairs
> = core.schemas.object({
  key: core.schemas.lazy(() => schemas.commons.DebugVariableValue),
  value: core.schemas.lazy(() => schemas.commons.DebugVariableValue),
});

export declare namespace DebugKeyValuePairs {
  interface Raw {
    key: schemas.commons.DebugVariableValue.Raw;
    value: schemas.commons.DebugVariableValue.Raw;
  }
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugMapValue: core.schemas.ObjectSchema<DebugMapValue.Raw, TraceApi.commons.DebugMapValue> =
  core.schemas.object({
    keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.DebugKeyValuePairs)),
  });

export declare namespace DebugMapValue {
  interface Raw {
    keyValuePairs: schemas.commons.DebugKeyValuePairs.Raw[];
  }
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugVariableValue: core.schemas.Schema<DebugVariableValue.Raw, TraceApi.commons.DebugVariableValue> =
  core.schemas
    .union(\\"type\\", {
      integerValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      booleanValue: core.schemas.object({
        value: core.schemas.boolean(),
      }),
      doubleValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      stringValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      charValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      mapValue: core.schemas.lazyObject(() => schemas.commons.DebugMapValue),
      listValue: core.schemas.object({
        value: core.schemas.list(core.schemas.lazy(() => schemas.commons.DebugVariableValue)),
      }),
      binaryTreeNodeValue: core.schemas.lazyObject(() => schemas.commons.BinaryTreeNodeAndTreeValue),
      singlyLinkedListNodeValue: core.schemas.lazyObject(() => schemas.commons.SinglyLinkedListNodeAndListValue),
      doublyLinkedListNodeValue: core.schemas.lazyObject(() => schemas.commons.DoublyLinkedListNodeAndListValue),
      undefinedValue: core.schemas.object({}),
      nullValue: core.schemas.object({}),
      genericValue: core.schemas.lazyObject(() => schemas.commons.GenericValue),
    })
    .transform<TraceApi.commons.DebugVariableValue>({
      parse: (value) => {
        switch (value.type) {
          case \\"integerValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.integerValue(value.value),
            };
          }
          case \\"booleanValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.booleanValue(value.value),
            };
          }
          case \\"doubleValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.doubleValue(value.value),
            };
          }
          case \\"stringValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.stringValue(value.value),
            };
          }
          case \\"charValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.charValue(value.value),
            };
          }
          case \\"mapValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.mapValue(value),
            };
          }
          case \\"listValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.listValue(value.value),
            };
          }
          case \\"binaryTreeNodeValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.binaryTreeNodeValue(value),
            };
          }
          case \\"singlyLinkedListNodeValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.singlyLinkedListNodeValue(value),
            };
          }
          case \\"doublyLinkedListNodeValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.doublyLinkedListNodeValue(value),
            };
          }
          case \\"undefinedValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.undefinedValue(),
            };
          }
          case \\"nullValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.nullValue(),
            };
          }
          case \\"genericValue\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.genericValue(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace DebugVariableValue {
  type Raw =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends schemas.commons.DebugMapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: schemas.commons.DebugVariableValue.Raw[];
  }

  interface BinaryTreeNodeValue extends schemas.commons.BinaryTreeNodeAndTreeValue.Raw {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends schemas.commons.SinglyLinkedListNodeAndListValue.Raw {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends schemas.commons.DoublyLinkedListNodeAndListValue.Raw {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue {
    type: \\"undefinedValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }

  interface GenericValue extends schemas.commons.GenericValue.Raw {
    type: \\"genericValue\\";
  }
}
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeAndListValue.Raw,
  TraceApi.commons.DoublyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullList: core.schemas.lazyObject(() => schemas.commons.DoublyLinkedListValue),
});

export declare namespace DoublyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullList: schemas.commons.DoublyLinkedListValue.Raw;
  }
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeValue.Raw,
  TraceApi.commons.DoublyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  prev: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    next?: schemas.commons.NodeId.Raw | null;
    prev?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<
  DoublyLinkedListValue.Raw,
  TraceApi.commons.DoublyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.commons.DoublyLinkedListNodeValue)
  ),
});

export declare namespace DoublyLinkedListValue {
  interface Raw {
    head?: schemas.commons.NodeId.Raw | null;
    nodes: Record<schemas.commons.NodeId.Raw, schemas.commons.DoublyLinkedListNodeValue.Raw>;
  }
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const FileInfo: core.schemas.ObjectSchema<FileInfo.Raw, TraceApi.commons.FileInfo> = core.schemas.object({
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace FileInfo {
  interface Raw {
    filename: string;
    contents: string;
  }
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericValue: core.schemas.ObjectSchema<GenericValue.Raw, TraceApi.commons.GenericValue> =
  core.schemas.object({
    stringifiedType: core.schemas.string().optional(),
    stringifiedValue: core.schemas.string(),
  });

export declare namespace GenericValue {
  interface Raw {
    stringifiedType?: string | null;
    stringifiedValue: string;
  }
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const KeyValuePair: core.schemas.ObjectSchema<KeyValuePair.Raw, TraceApi.commons.KeyValuePair> =
  core.schemas.object({
    key: core.schemas.lazy(() => schemas.commons.VariableValue),
    value: core.schemas.lazy(() => schemas.commons.VariableValue),
  });

export declare namespace KeyValuePair {
  interface Raw {
    key: schemas.commons.VariableValue.Raw;
    value: schemas.commons.VariableValue.Raw;
  }
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<Language.Raw, TraceApi.commons.Language> = core.schemas
  .string()
  .transform<TraceApi.commons.Language>({
    parse: (value) => {
      switch (value) {
        case \\"JAVA\\": {
          return TraceApi.commons.Language.Java;
        }
        case \\"JAVASCRIPT\\": {
          return TraceApi.commons.Language.Javascript;
        }
        case \\"PYTHON\\": {
          return TraceApi.commons.Language.Python;
        }
        default: {
          return {
            toString: () => value,
            visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value.toString(),
  });

export declare namespace Language {
  type Raw = string;
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ListType: core.schemas.ObjectSchema<ListType.Raw, TraceApi.commons.ListType> = core.schemas.object({
  valueType: core.schemas.lazy(() => schemas.commons.VariableType),
  isFixedLength: core.schemas.boolean().optional(),
});

export declare namespace ListType {
  interface Raw {
    valueType: schemas.commons.VariableType.Raw;
    isFixedLength?: boolean | null;
  }
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const MapType: core.schemas.ObjectSchema<MapType.Raw, TraceApi.commons.MapType> = core.schemas.object({
  keyType: core.schemas.lazy(() => schemas.commons.VariableType),
  valueType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace MapType {
  interface Raw {
    keyType: schemas.commons.VariableType.Raw;
    valueType: schemas.commons.VariableType.Raw;
  }
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const MapValue: core.schemas.ObjectSchema<MapValue.Raw, TraceApi.commons.MapValue> = core.schemas.object({
  keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.KeyValuePair)),
});

export declare namespace MapValue {
  interface Raw {
    keyValuePairs: schemas.commons.KeyValuePair.Raw[];
  }
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const NodeId: core.schemas.Schema<NodeId.Raw, TraceApi.commons.NodeId> = core.schemas.string();

export declare namespace NodeId {
  type Raw = string;
}
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ProblemId: core.schemas.Schema<ProblemId.Raw, TraceApi.commons.ProblemId> = core.schemas.string();

export declare namespace ProblemId {
  type Raw = string;
}
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeAndListValue.Raw,
  TraceApi.commons.SinglyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullList: core.schemas.lazyObject(() => schemas.commons.SinglyLinkedListValue),
});

export declare namespace SinglyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullList: schemas.commons.SinglyLinkedListValue.Raw;
  }
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeValue.Raw,
  TraceApi.commons.SinglyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    next?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<
  SinglyLinkedListValue.Raw,
  TraceApi.commons.SinglyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.commons.SinglyLinkedListNodeValue)
  ),
});

export declare namespace SinglyLinkedListValue {
  interface Raw {
    head?: schemas.commons.NodeId.Raw | null;
    nodes: Record<schemas.commons.NodeId.Raw, schemas.commons.SinglyLinkedListNodeValue.Raw>;
  }
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCase: core.schemas.ObjectSchema<TestCase.Raw, TraceApi.commons.TestCase> = core.schemas.object({
  id: core.schemas.string(),
  params: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableValue)),
});

export declare namespace TestCase {
  interface Raw {
    id: string;
    params: schemas.commons.VariableValue.Raw[];
  }
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<
  TestCaseWithExpectedResult.Raw,
  TraceApi.commons.TestCaseWithExpectedResult
> = core.schemas.object({
  testCase: core.schemas.lazyObject(() => schemas.commons.TestCase),
  expectedResult: core.schemas.lazy(() => schemas.commons.VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
  interface Raw {
    testCase: schemas.commons.TestCase.Raw;
    expectedResult: schemas.commons.VariableValue.Raw;
  }
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UserId: core.schemas.Schema<UserId.Raw, TraceApi.commons.UserId> = core.schemas.string();

export declare namespace UserId {
  type Raw = string;
}
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableType: core.schemas.Schema<VariableType.Raw, TraceApi.commons.VariableType> = core.schemas
  .union(\\"type\\", {
    integerType: core.schemas.object({}),
    doubleType: core.schemas.object({}),
    booleanType: core.schemas.object({}),
    stringType: core.schemas.object({}),
    charType: core.schemas.object({}),
    listType: core.schemas.lazyObject(() => schemas.commons.ListType),
    mapType: core.schemas.lazyObject(() => schemas.commons.MapType),
    binaryTreeType: core.schemas.object({}),
    singlyLinkedListType: core.schemas.object({}),
    doublyLinkedListType: core.schemas.object({}),
  })
  .transform<TraceApi.commons.VariableType>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.integerType(),
          };
        }
        case \\"doubleType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doubleType(),
          };
        }
        case \\"booleanType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.booleanType(),
          };
        }
        case \\"stringType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stringType(),
          };
        }
        case \\"charType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.charType(),
          };
        }
        case \\"listType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.listType(value),
          };
        }
        case \\"mapType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.mapType(value),
          };
        }
        case \\"binaryTreeType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.binaryTreeType(),
          };
        }
        case \\"singlyLinkedListType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.singlyLinkedListType(),
          };
        }
        case \\"doublyLinkedListType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doublyLinkedListType(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableType {
  type Raw =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

  interface IntegerType {
    type: \\"integerType\\";
  }

  interface DoubleType {
    type: \\"doubleType\\";
  }

  interface BooleanType {
    type: \\"booleanType\\";
  }

  interface StringType {
    type: \\"stringType\\";
  }

  interface CharType {
    type: \\"charType\\";
  }

  interface ListType extends schemas.commons.ListType.Raw {
    type: \\"listType\\";
  }

  interface MapType extends schemas.commons.MapType.Raw {
    type: \\"mapType\\";
  }

  interface BinaryTreeType {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType {
    type: \\"doublyLinkedListType\\";
  }
}
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableValue: core.schemas.Schema<VariableValue.Raw, TraceApi.commons.VariableValue> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => schemas.commons.MapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableValue)),
    }),
    binaryTreeValue: core.schemas.lazyObject(() => schemas.commons.BinaryTreeValue),
    singlyLinkedListValue: core.schemas.lazyObject(() => schemas.commons.SinglyLinkedListValue),
    doublyLinkedListValue: core.schemas.lazyObject(() => schemas.commons.DoublyLinkedListValue),
    nullValue: core.schemas.object({}),
  })
  .transform<TraceApi.commons.VariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.integerValue(value.value),
          };
        }
        case \\"booleanValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.booleanValue(value.value),
          };
        }
        case \\"doubleValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doubleValue(value.value),
          };
        }
        case \\"stringValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stringValue(value.value),
          };
        }
        case \\"charValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.charValue(value.value),
          };
        }
        case \\"mapValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.mapValue(value),
          };
        }
        case \\"listValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.listValue(value.value),
          };
        }
        case \\"binaryTreeValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.binaryTreeValue(value),
          };
        }
        case \\"singlyLinkedListValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.singlyLinkedListValue(value),
          };
        }
        case \\"doublyLinkedListValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doublyLinkedListValue(value),
          };
        }
        case \\"nullValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nullValue(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableValue {
  type Raw =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends schemas.commons.MapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: schemas.commons.VariableValue.Raw[];
  }

  interface BinaryTreeValue extends schemas.commons.BinaryTreeValue.Raw {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends schemas.commons.SinglyLinkedListValue.Raw {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends schemas.commons.DoublyLinkedListValue.Raw {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }
}
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<schemas.commons.ProblemId.Raw[], TraceApi.commons.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<schemas.commons.ProblemId.Raw[], TraceApi.commons.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerRequest: core.schemas.ObjectSchema<
  LangServerRequest.Raw,
  TraceApi.langServer.LangServerRequest
> = core.schemas.object({
  request: core.schemas.unknown(),
});

export declare namespace LangServerRequest {
  interface Raw {
    request?: unknown;
  }
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerResponse: core.schemas.ObjectSchema<
  LangServerResponse.Raw,
  TraceApi.langServer.LangServerResponse
> = core.schemas.object({
  response: core.schemas.unknown(),
});

export declare namespace LangServerResponse {
  interface Raw {
    response?: unknown;
  }
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<schemas.migration.Migration.Raw[], TraceApi.migration.Migration[]> =
  core.schemas.list(core.schemas.lazyObject(() => schemas.migration.Migration));
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Migration: core.schemas.ObjectSchema<Migration.Raw, TraceApi.migration.Migration> = core.schemas.object({
  name: core.schemas.string(),
  status: core.schemas.lazy(() => schemas.migration.MigrationStatus),
});

export declare namespace Migration {
  interface Raw {
    name: string;
    status: schemas.migration.MigrationStatus.Raw;
  }
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<MigrationStatus.Raw, TraceApi.migration.MigrationStatus> =
  core.schemas.string().transform<TraceApi.migration.MigrationStatus>({
    parse: (value) => {
      switch (value) {
        case \\"RUNNING\\": {
          return TraceApi.migration.MigrationStatus.Running;
        }
        case \\"FAILED\\": {
          return TraceApi.migration.MigrationStatus.Failed;
        }
        case \\"FINISHED\\": {
          return TraceApi.migration.MigrationStatus.Finished;
        }
        default: {
          return {
            toString: () => value,
            visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value.toString(),
  });

export declare namespace MigrationStatus {
  type Raw = string;
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Error: core.schemas.Schema<Error.Raw, TraceApi.playlist.getPlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => schemas.playlist.PlaylistIdNotFoundError),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<TraceApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
        case \\"UnauthorizedError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.unauthorizedError(),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<schemas.playlist.Playlist.Raw[], TraceApi.playlist.Playlist[]> =
  core.schemas.list(core.schemas.lazyObject(() => schemas.playlist.Playlist));
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.playlist.UpdatePlaylistRequest.Raw | null | undefined,
  TraceApi.playlist.UpdatePlaylistRequest | undefined
> = core.schemas.lazyObject(() => schemas.playlist.UpdatePlaylistRequest).optional();
export const Response: core.schemas.Schema<
  schemas.playlist.Playlist.Raw | null | undefined,
  TraceApi.playlist.Playlist | undefined
> = core.schemas.lazyObject(() => schemas.playlist.Playlist).optional();
export const Error: core.schemas.Schema<Error.Raw, TraceApi.playlist.updatePlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => schemas.playlist.PlaylistIdNotFoundError),
    }),
  })
  .transform<TraceApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }
}
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  PlaylistIdNotFoundError.Raw,
  TraceApi.playlist.PlaylistIdNotFoundError
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.playlist.PlaylistId),
    }),
  })
  .transform<TraceApi.playlist.PlaylistIdNotFoundError>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundError {
  type Raw = PlaylistIdNotFoundError.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: schemas.playlist.PlaylistId.Raw;
  }
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Playlist: core.schemas.ObjectSchema<Playlist.Raw, TraceApi.playlist.Playlist> = core.schemas
  .object({
    playlistId: core.schemas.property(
      \\"playlist_id\\",
      core.schemas.lazy(() => schemas.playlist.PlaylistId)
    ),
    ownerId: core.schemas.property(
      \\"owner-id\\",
      core.schemas.lazy(() => schemas.commons.UserId)
    ),
  })
  .extend(core.schemas.lazyObject(() => schemas.playlist.PlaylistCreateRequest));

export declare namespace Playlist {
  interface Raw extends schemas.playlist.PlaylistCreateRequest.Raw {
    playlist_id: schemas.playlist.PlaylistId.Raw;
    \\"owner-id\\": schemas.commons.UserId.Raw;
  }
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<
  PlaylistCreateRequest.Raw,
  TraceApi.playlist.PlaylistCreateRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId)),
});

export declare namespace PlaylistCreateRequest {
  interface Raw {
    name: string;
    problems: schemas.commons.ProblemId.Raw[];
  }
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const PlaylistId: core.schemas.Schema<PlaylistId.Raw, TraceApi.playlist.PlaylistId> = core.schemas.string();

export declare namespace PlaylistId {
  type Raw = string;
}
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<
  UpdatePlaylistRequest.Raw,
  TraceApi.playlist.UpdatePlaylistRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId)),
});

export declare namespace UpdatePlaylistRequest {
  interface Raw {
    name: string;
    problems: schemas.commons.ProblemId.Raw[];
  }
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemError: core.schemas.Schema<CreateProblemError.Raw, TraceApi.problem.CreateProblemError> =
  core.schemas
    .union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
      generic: core.schemas.lazyObject(() => schemas.problem.GenericCreateProblemError),
    })
    .transform<TraceApi.problem.CreateProblemError>({
      parse: (value) => {
        switch (value.errorType) {
          case \\"generic\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.generic(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace CreateProblemError {
  type Raw = CreateProblemError.Generic;

  interface Generic extends schemas.problem.GenericCreateProblemError.Raw {
    _type: \\"generic\\";
  }
}
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<
  CreateProblemRequest.Raw,
  TraceApi.problem.CreateProblemRequest
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
  ),
  inputParams: core.schemas.list(core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => schemas.commons.VariableType),
  testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.TestCaseWithExpectedResult)),
  methodName: core.schemas.string(),
});

export declare namespace CreateProblemRequest {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    files: Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    testcases: schemas.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
  }
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemResponse: core.schemas.Schema<
  CreateProblemResponse.Raw,
  TraceApi.problem.CreateProblemResponse
> = core.schemas
  .union(\\"type\\", {
    success: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.ProblemId),
    }),
    error: core.schemas.object({
      value: core.schemas.lazy(() => schemas.problem.CreateProblemError),
    }),
  })
  .transform<TraceApi.problem.CreateProblemResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"success\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.success(value.value),
          };
        }
        case \\"error\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.error(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemResponse {
  type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

  interface Success {
    type: \\"success\\";
    value: schemas.commons.ProblemId.Raw;
  }

  interface Error {
    type: \\"error\\";
    value: schemas.problem.CreateProblemError.Raw;
  }
}
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<
  GenericCreateProblemError.Raw,
  TraceApi.problem.GenericCreateProblemError
> = core.schemas.object({
  message: core.schemas.string(),
  type: core.schemas.string(),
  stacktrace: core.schemas.string(),
});

export declare namespace GenericCreateProblemError {
  interface Raw {
    message: string;
    type: string;
    stacktrace: string;
  }
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetDefaultStarterFilesRequest: core.schemas.ObjectSchema<
  GetDefaultStarterFilesRequest.Raw,
  TraceApi.problem.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => schemas.commons.VariableType),
  methodName: core.schemas.string(),
});

export declare namespace GetDefaultStarterFilesRequest {
  interface Raw {
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    methodName: string;
  }
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<
  GetDefaultStarterFilesResponse.Raw,
  TraceApi.problem.GetDefaultStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
  ),
});

export declare namespace GetDefaultStarterFilesResponse {
  interface Raw {
    files: Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
  }
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemDescription: core.schemas.ObjectSchema<
  ProblemDescription.Raw,
  TraceApi.problem.ProblemDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => schemas.problem.ProblemDescriptionBoard)),
});

export declare namespace ProblemDescription {
  interface Raw {
    boards: schemas.problem.ProblemDescriptionBoard.Raw[];
  }
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemDescriptionBoard: core.schemas.Schema<
  ProblemDescriptionBoard.Raw,
  TraceApi.problem.ProblemDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    variable: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.VariableValue),
    }),
    testCaseId: core.schemas.object({
      value: core.schemas.string(),
    }),
  })
  .transform<TraceApi.problem.ProblemDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"variable\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.variable(value.value),
          };
        }
        case \\"testCaseId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.testCaseId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ProblemDescriptionBoard {
  type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface Variable {
    type: \\"variable\\";
    value: schemas.commons.VariableValue.Raw;
  }

  interface TestCaseId {
    type: \\"testCaseId\\";
    value: string;
  }
}
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemFiles: core.schemas.ObjectSchema<ProblemFiles.Raw, TraceApi.problem.ProblemFiles> =
  core.schemas.object({
    solutionFile: core.schemas.lazyObject(() => schemas.commons.FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.FileInfo)),
  });

export declare namespace ProblemFiles {
  interface Raw {
    solutionFile: schemas.commons.FileInfo.Raw;
    readOnlyFiles: schemas.commons.FileInfo.Raw[];
  }
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemInfo: core.schemas.ObjectSchema<ProblemInfo.Raw, TraceApi.problem.ProblemInfo> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    files: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
    ),
    inputParams: core.schemas.list(core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)),
    outputType: core.schemas.lazy(() => schemas.commons.VariableType),
    testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.TestCaseWithExpectedResult)),
    methodName: core.schemas.string(),
    supportsCustomTestCases: core.schemas.boolean(),
  });

export declare namespace ProblemInfo {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    files: Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    testcases: schemas.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
    supportsCustomTestCases: boolean;
  }
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<
  UpdateProblemResponse.Raw,
  TraceApi.problem.UpdateProblemResponse
> = core.schemas.object({
  problemVersion: core.schemas.number(),
});

export declare namespace UpdateProblemResponse {
  interface Raw {
    problemVersion: number;
  }
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<
  VariableTypeAndName.Raw,
  TraceApi.problem.VariableTypeAndName
> = core.schemas.object({
  variableType: core.schemas.lazy(() => schemas.commons.VariableType),
  name: core.schemas.string(),
});

export declare namespace VariableTypeAndName {
  interface Raw {
    variableType: schemas.commons.VariableType.Raw;
    name: string;
  }
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.submission.ExecutionSessionResponse.Raw | null | undefined,
  TraceApi.submission.ExecutionSessionResponse | undefined
> = core.schemas.lazyObject(() => schemas.submission.ExecutionSessionResponse).optional();
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ActualResult: core.schemas.Schema<ActualResult.Raw, TraceApi.submission.ActualResult> = core.schemas
  .union(\\"type\\", {
    value: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.VariableValue),
    }),
    exception: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
    exceptionV2: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ExceptionV2),
    }),
  })
  .transform<TraceApi.submission.ActualResult>({
    parse: (value) => {
      switch (value.type) {
        case \\"value\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.value(value.value),
          };
        }
        case \\"exception\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.exception(value),
          };
        }
        case \\"exceptionV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.exceptionV2(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ActualResult {
  type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

  interface Value {
    type: \\"value\\";
    value: schemas.commons.VariableValue.Raw;
  }

  interface Exception extends schemas.submission.ExceptionInfo.Raw {
    type: \\"exception\\";
  }

  interface ExceptionV2 {
    type: \\"exceptionV2\\";
    value: schemas.submission.ExceptionV2.Raw;
  }
}
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<
  BuildingExecutorResponse.Raw,
  TraceApi.submission.BuildingExecutorResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CodeExecutionUpdate: core.schemas.Schema<
  CodeExecutionUpdate.Raw,
  TraceApi.submission.CodeExecutionUpdate
> = core.schemas
  .union(\\"type\\", {
    buildingExecutor: core.schemas.lazyObject(() => schemas.submission.BuildingExecutorResponse),
    running: core.schemas.lazyObject(() => schemas.submission.RunningResponse),
    errored: core.schemas.lazyObject(() => schemas.submission.ErroredResponse),
    stopped: core.schemas.lazyObject(() => schemas.submission.StoppedResponse),
    graded: core.schemas.lazyObject(() => schemas.submission.GradedResponse),
    gradedV2: core.schemas.lazyObject(() => schemas.submission.GradedResponseV2),
    workspaceRan: core.schemas.lazyObject(() => schemas.submission.WorkspaceRanResponse),
    recording: core.schemas.lazyObject(() => schemas.submission.RecordingResponseNotification),
    recorded: core.schemas.lazyObject(() => schemas.submission.RecordedResponseNotification),
    invalidRequest: core.schemas.lazyObject(() => schemas.submission.InvalidRequestResponse),
    finished: core.schemas.lazyObject(() => schemas.submission.FinishedResponse),
  })
  .transform<TraceApi.submission.CodeExecutionUpdate>({
    parse: (value) => {
      switch (value.type) {
        case \\"buildingExecutor\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.buildingExecutor(value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(value),
          };
        }
        case \\"graded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.graded(value),
          };
        }
        case \\"gradedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedV2(value),
          };
        }
        case \\"workspaceRan\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspaceRan(value),
          };
        }
        case \\"recording\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recording(value),
          };
        }
        case \\"recorded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recorded(value),
          };
        }
        case \\"invalidRequest\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.invalidRequest(value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CodeExecutionUpdate {
  type Raw =
    | CodeExecutionUpdate.BuildingExecutor
    | CodeExecutionUpdate.Running
    | CodeExecutionUpdate.Errored
    | CodeExecutionUpdate.Stopped
    | CodeExecutionUpdate.Graded
    | CodeExecutionUpdate.GradedV2
    | CodeExecutionUpdate.WorkspaceRan
    | CodeExecutionUpdate.Recording
    | CodeExecutionUpdate.Recorded
    | CodeExecutionUpdate.InvalidRequest
    | CodeExecutionUpdate.Finished;

  interface BuildingExecutor extends schemas.submission.BuildingExecutorResponse.Raw {
    type: \\"buildingExecutor\\";
  }

  interface Running extends schemas.submission.RunningResponse.Raw {
    type: \\"running\\";
  }

  interface Errored extends schemas.submission.ErroredResponse.Raw {
    type: \\"errored\\";
  }

  interface Stopped extends schemas.submission.StoppedResponse.Raw {
    type: \\"stopped\\";
  }

  interface Graded extends schemas.submission.GradedResponse.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 extends schemas.submission.GradedResponseV2.Raw {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends schemas.submission.WorkspaceRanResponse.Raw {
    type: \\"workspaceRan\\";
  }

  interface Recording extends schemas.submission.RecordingResponseNotification.Raw {
    type: \\"recording\\";
  }

  interface Recorded extends schemas.submission.RecordedResponseNotification.Raw {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends schemas.submission.InvalidRequestResponse.Raw {
    type: \\"invalidRequest\\";
  }

  interface Finished extends schemas.submission.FinishedResponse.Raw {
    type: \\"finished\\";
  }
}
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const CompileError: core.schemas.ObjectSchema<CompileError.Raw, TraceApi.submission.CompileError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace CompileError {
  interface Raw {
    message: string;
  }
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<
  CustomTestCasesUnsupported.Raw,
  TraceApi.submission.CustomTestCasesUnsupported
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ErrorInfo: core.schemas.Schema<ErrorInfo.Raw, TraceApi.submission.ErrorInfo> = core.schemas
  .union(\\"type\\", {
    compileError: core.schemas.lazyObject(() => schemas.submission.CompileError),
    runtimeError: core.schemas.lazyObject(() => schemas.submission.RuntimeError),
    internalError: core.schemas.lazyObject(() => schemas.submission.InternalError),
  })
  .transform<TraceApi.submission.ErrorInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"compileError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.compileError(value),
          };
        }
        case \\"runtimeError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.runtimeError(value),
          };
        }
        case \\"internalError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.internalError(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ErrorInfo {
  type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

  interface CompileError extends schemas.submission.CompileError.Raw {
    type: \\"compileError\\";
  }

  interface RuntimeError extends schemas.submission.RuntimeError.Raw {
    type: \\"runtimeError\\";
  }

  interface InternalError extends schemas.submission.InternalError.Raw {
    type: \\"internalError\\";
  }
}
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ErroredResponse: core.schemas.ObjectSchema<ErroredResponse.Raw, TraceApi.submission.ErroredResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    errorInfo: core.schemas.lazy(() => schemas.submission.ErrorInfo),
  });

export declare namespace ErroredResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    errorInfo: schemas.submission.ErrorInfo.Raw;
  }
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExceptionInfo: core.schemas.ObjectSchema<ExceptionInfo.Raw, TraceApi.submission.ExceptionInfo> =
  core.schemas.object({
    exceptionType: core.schemas.string(),
    exceptionMessage: core.schemas.string(),
    exceptionStacktrace: core.schemas.string(),
  });

export declare namespace ExceptionInfo {
  interface Raw {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
  }
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExceptionV2: core.schemas.Schema<ExceptionV2.Raw, TraceApi.submission.ExceptionV2> = core.schemas
  .union(\\"type\\", {
    generic: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
    timeout: core.schemas.object({}),
  })
  .transform<TraceApi.submission.ExceptionV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"generic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.generic(value),
          };
        }
        case \\"timeout\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.timeout(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ExceptionV2 {
  type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

  interface Generic extends schemas.submission.ExceptionInfo.Raw {
    type: \\"generic\\";
  }

  interface Timeout {
    type: \\"timeout\\";
  }
}
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<
  ExecutionSessionResponse.Raw,
  TraceApi.submission.ExecutionSessionResponse
> = core.schemas.object({
  sessionId: core.schemas.string(),
  executionSessionUrl: core.schemas.string().optional(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
  interface Raw {
    sessionId: string;
    executionSessionUrl?: string | null;
    language: schemas.commons.Language.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<
  ExecutionSessionState.Raw,
  TraceApi.submission.ExecutionSessionState
> = core.schemas.object({
  lastTimeContacted: core.schemas.string().optional(),
  sessionId: core.schemas.string(),
  isWarmInstance: core.schemas.boolean(),
  awsTaskId: core.schemas.string().optional(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
  interface Raw {
    lastTimeContacted?: string | null;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string | null;
    language: schemas.commons.Language.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<
  ExecutionSessionStatus.Raw,
  TraceApi.submission.ExecutionSessionStatus
> = core.schemas.string().transform<TraceApi.submission.ExecutionSessionStatus>({
  parse: (value) => {
    switch (value) {
      case \\"CREATING_CONTAINER\\": {
        return TraceApi.submission.ExecutionSessionStatus.CreatingContainer;
      }
      case \\"PROVISIONING_CONTAINER\\": {
        return TraceApi.submission.ExecutionSessionStatus.ProvisioningContainer;
      }
      case \\"PENDING_CONTAINER\\": {
        return TraceApi.submission.ExecutionSessionStatus.PendingContainer;
      }
      case \\"RUNNING_CONTAINER\\": {
        return TraceApi.submission.ExecutionSessionStatus.RunningContainer;
      }
      case \\"LIVE_CONTAINER\\": {
        return TraceApi.submission.ExecutionSessionStatus.LiveContainer;
      }
      case \\"FAILED_TO_LAUNCH\\": {
        return TraceApi.submission.ExecutionSessionStatus.FailedToLaunch;
      }
      default: {
        return {
          toString: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.toString(),
});

export declare namespace ExecutionSessionStatus {
  type Raw = string;
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<
  ExistingSubmissionExecuting.Raw,
  TraceApi.submission.ExistingSubmissionExecuting
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExpressionLocation: core.schemas.ObjectSchema<
  ExpressionLocation.Raw,
  TraceApi.submission.ExpressionLocation
> = core.schemas.object({
  start: core.schemas.number(),
  offset: core.schemas.number(),
});

export declare namespace ExpressionLocation {
  interface Raw {
    start: number;
    offset: number;
  }
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const FinishedResponse: core.schemas.ObjectSchema<FinishedResponse.Raw, TraceApi.submission.FinishedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  });

export declare namespace FinishedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<
  GetExecutionSessionStateResponse.Raw,
  TraceApi.submission.GetExecutionSessionStateResponse
> = core.schemas.object({
  states: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.submission.ExecutionSessionState)
  ),
  numWarmingInstances: core.schemas.number().optional(),
  warmingSessionIds: core.schemas.list(core.schemas.string()),
});

export declare namespace GetExecutionSessionStateResponse {
  interface Raw {
    states: Record<string, schemas.submission.ExecutionSessionState.Raw>;
    numWarmingInstances?: number | null;
    warmingSessionIds: string[];
  }
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<
  GetSubmissionStateResponse.Raw,
  TraceApi.submission.GetSubmissionStateResponse
> = core.schemas.object({
  timeSubmitted: core.schemas.date().optional(),
  submission: core.schemas.string(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  submissionTypeState: core.schemas.lazy(() => schemas.submission.SubmissionTypeState),
});

export declare namespace GetSubmissionStateResponse {
  interface Raw {
    timeSubmitted?: string | null;
    submission: string;
    language: schemas.commons.Language.Raw;
    submissionTypeState: schemas.submission.SubmissionTypeState.Raw;
  }
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<
  GetTraceResponsesPageRequest.Raw,
  TraceApi.submission.GetTraceResponsesPageRequest
> = core.schemas.object({
  offset: core.schemas.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
  interface Raw {
    offset?: number | null;
  }
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedResponse: core.schemas.ObjectSchema<GradedResponse.Raw, TraceApi.submission.GradedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.submission.TestCaseResultWithStdout)
    ),
  });

export declare namespace GradedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCases: Record<string, schemas.submission.TestCaseResultWithStdout.Raw>;
  }
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedResponseV2: core.schemas.ObjectSchema<GradedResponseV2.Raw, TraceApi.submission.GradedResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => schemas.submission.TestCaseGrade)
    ),
  });

export declare namespace GradedResponseV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCases: Record<schemas.v2.problem.TestCaseId.Raw, schemas.submission.TestCaseGrade.Raw>;
  }
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<
  GradedTestCaseUpdate.Raw,
  TraceApi.submission.GradedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
  grade: core.schemas.lazy(() => schemas.submission.TestCaseGrade),
});

export declare namespace GradedTestCaseUpdate {
  interface Raw {
    testCaseId: schemas.v2.problem.TestCaseId.Raw;
    grade: schemas.submission.TestCaseGrade.Raw;
  }
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<
  InitializeProblemRequest.Raw,
  TraceApi.submission.InitializeProblemRequest
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemVersion: core.schemas.number().optional(),
});

export declare namespace InitializeProblemRequest {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion?: number | null;
  }
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InternalError: core.schemas.ObjectSchema<InternalError.Raw, TraceApi.submission.InternalError> =
  core.schemas.object({
    exceptionInfo: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
  });

export declare namespace InternalError {
  interface Raw {
    exceptionInfo: schemas.submission.ExceptionInfo.Raw;
  }
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InvalidRequestCause: core.schemas.Schema<
  InvalidRequestCause.Raw,
  TraceApi.submission.InvalidRequestCause
> = core.schemas
  .union(\\"type\\", {
    submissionIdNotFound: core.schemas.lazyObject(() => schemas.submission.SubmissionIdNotFound),
    customTestCasesUnsupported: core.schemas.lazyObject(() => schemas.submission.CustomTestCasesUnsupported),
    unexpectedLanguage: core.schemas.lazyObject(() => schemas.submission.UnexpectedLanguageError),
  })
  .transform<TraceApi.submission.InvalidRequestCause>({
    parse: (value) => {
      switch (value.type) {
        case \\"submissionIdNotFound\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.submissionIdNotFound(value),
          };
        }
        case \\"customTestCasesUnsupported\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.customTestCasesUnsupported(value),
          };
        }
        case \\"unexpectedLanguage\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.unexpectedLanguage(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace InvalidRequestCause {
  type Raw =
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    | InvalidRequestCause.UnexpectedLanguage;

  interface SubmissionIdNotFound extends schemas.submission.SubmissionIdNotFound.Raw {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends schemas.submission.CustomTestCasesUnsupported.Raw {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends schemas.submission.UnexpectedLanguageError.Raw {
    type: \\"unexpectedLanguage\\";
  }
}
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<
  InvalidRequestResponse.Raw,
  TraceApi.submission.InvalidRequestResponse
> = core.schemas.object({
  request: core.schemas.lazy(() => schemas.submission.SubmissionRequest),
  cause: core.schemas.lazy(() => schemas.submission.InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
  interface Raw {
    request: schemas.submission.SubmissionRequest.Raw;
    cause: schemas.submission.InvalidRequestCause.Raw;
  }
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<
  LightweightStackframeInformation.Raw,
  TraceApi.submission.LightweightStackframeInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrameMethodName: core.schemas.string(),
});

export declare namespace LightweightStackframeInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrameMethodName: string;
  }
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<
  RecordedResponseNotification.Raw,
  TraceApi.submission.RecordedResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  traceResponsesSize: core.schemas.number(),
  testCaseId: core.schemas.string().optional(),
});

export declare namespace RecordedResponseNotification {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    traceResponsesSize: number;
    testCaseId?: string | null;
  }
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<
  RecordedTestCaseUpdate.Raw,
  TraceApi.submission.RecordedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace RecordedTestCaseUpdate {
  interface Raw {
    testCaseId: schemas.v2.problem.TestCaseId.Raw;
    traceResponsesSize: number;
  }
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<
  RecordingResponseNotification.Raw,
  TraceApi.submission.RecordingResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  testCaseId: core.schemas.string().optional(),
  lineNumber: core.schemas.number(),
  lightweightStackInfo: core.schemas.lazyObject(() => schemas.submission.LightweightStackframeInformation),
  tracedFile: core.schemas.lazyObject(() => schemas.submission.TracedFile).optional(),
});

export declare namespace RecordingResponseNotification {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCaseId?: string | null;
    lineNumber: number;
    lightweightStackInfo: schemas.submission.LightweightStackframeInformation.Raw;
    tracedFile?: schemas.submission.TracedFile.Raw | null;
  }
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RunningResponse: core.schemas.ObjectSchema<RunningResponse.Raw, TraceApi.submission.RunningResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    state: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
  });

export declare namespace RunningResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    state: schemas.submission.RunningSubmissionState.Raw;
  }
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<
  RunningSubmissionState.Raw,
  TraceApi.submission.RunningSubmissionState
> = core.schemas.string().transform<TraceApi.submission.RunningSubmissionState>({
  parse: (value) => {
    switch (value) {
      case \\"QUEUEING_SUBMISSION\\": {
        return TraceApi.submission.RunningSubmissionState.QueueingSubmission;
      }
      case \\"KILLING_HISTORICAL_SUBMISSIONS\\": {
        return TraceApi.submission.RunningSubmissionState.KillingHistoricalSubmissions;
      }
      case \\"WRITING_SUBMISSION_TO_FILE\\": {
        return TraceApi.submission.RunningSubmissionState.WritingSubmissionToFile;
      }
      case \\"COMPILING_SUBMISSION\\": {
        return TraceApi.submission.RunningSubmissionState.CompilingSubmission;
      }
      case \\"RUNNING_SUBMISSION\\": {
        return TraceApi.submission.RunningSubmissionState.RunningSubmission;
      }
      default: {
        return {
          toString: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.toString(),
});

export declare namespace RunningSubmissionState {
  type Raw = string;
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RuntimeError: core.schemas.ObjectSchema<RuntimeError.Raw, TraceApi.submission.RuntimeError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace RuntimeError {
  interface Raw {
    message: string;
  }
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Scope: core.schemas.ObjectSchema<Scope.Raw, TraceApi.submission.Scope> = core.schemas.object({
  variables: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => schemas.commons.DebugVariableValue)
  ),
});

export declare namespace Scope {
  interface Raw {
    variables: Record<string, schemas.commons.DebugVariableValue.Raw>;
  }
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ShareId: core.schemas.Schema<ShareId.Raw, TraceApi.submission.ShareId> = core.schemas.string();

export declare namespace ShareId {
  type Raw = string;
}
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StackFrame: core.schemas.ObjectSchema<StackFrame.Raw, TraceApi.submission.StackFrame> =
  core.schemas.object({
    methodName: core.schemas.string(),
    lineNumber: core.schemas.number(),
    scopes: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.Scope)),
  });

export declare namespace StackFrame {
  interface Raw {
    methodName: string;
    lineNumber: number;
    scopes: schemas.submission.Scope.Raw[];
  }
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StackInformation: core.schemas.ObjectSchema<StackInformation.Raw, TraceApi.submission.StackInformation> =
  core.schemas.object({
    numStackFrames: core.schemas.number(),
    topStackFrame: core.schemas.lazyObject(() => schemas.submission.StackFrame).optional(),
  });

export declare namespace StackInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrame?: schemas.submission.StackFrame.Raw | null;
  }
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StderrResponse: core.schemas.ObjectSchema<StderrResponse.Raw, TraceApi.submission.StderrResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    stderr: core.schemas.string(),
  });

export declare namespace StderrResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    stderr: string;
  }
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StdoutResponse: core.schemas.ObjectSchema<StdoutResponse.Raw, TraceApi.submission.StdoutResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    stdout: core.schemas.string(),
  });

export declare namespace StdoutResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    stdout: string;
  }
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StopRequest: core.schemas.ObjectSchema<StopRequest.Raw, TraceApi.submission.StopRequest> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  });

export declare namespace StopRequest {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoppedResponse: core.schemas.ObjectSchema<StoppedResponse.Raw, TraceApi.submission.StoppedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  });

export declare namespace StoppedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<
  SubmissionFileInfo.Raw,
  TraceApi.submission.SubmissionFileInfo
> = core.schemas.object({
  directory: core.schemas.string(),
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace SubmissionFileInfo {
  interface Raw {
    directory: string;
    filename: string;
    contents: string;
  }
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionId: core.schemas.Schema<SubmissionId.Raw, TraceApi.submission.SubmissionId> =
  core.schemas.string();

export declare namespace SubmissionId {
  type Raw = string;
}
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<
  SubmissionIdNotFound.Raw,
  TraceApi.submission.SubmissionIdNotFound
> = core.schemas.object({
  missingSubmissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace SubmissionIdNotFound {
  interface Raw {
    missingSubmissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionRequest: core.schemas.Schema<SubmissionRequest.Raw, TraceApi.submission.SubmissionRequest> =
  core.schemas
    .union(\\"type\\", {
      initializeProblemRequest: core.schemas.lazyObject(() => schemas.submission.InitializeProblemRequest),
      initializeWorkspaceRequest: core.schemas.object({}),
      submitV2: core.schemas.lazyObject(() => schemas.submission.SubmitRequestV2),
      workspaceSubmit: core.schemas.lazyObject(() => schemas.submission.WorkspaceSubmitRequest),
      stop: core.schemas.lazyObject(() => schemas.submission.StopRequest),
    })
    .transform<TraceApi.submission.SubmissionRequest>({
      parse: (value) => {
        switch (value.type) {
          case \\"initializeProblemRequest\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.initializeProblemRequest(value),
            };
          }
          case \\"initializeWorkspaceRequest\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.initializeWorkspaceRequest(),
            };
          }
          case \\"submitV2\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.submitV2(value),
            };
          }
          case \\"workspaceSubmit\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.workspaceSubmit(value),
            };
          }
          case \\"stop\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.stop(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionRequest {
  type Raw =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

  interface InitializeProblemRequest extends schemas.submission.InitializeProblemRequest.Raw {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends schemas.submission.SubmitRequestV2.Raw {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends schemas.submission.WorkspaceSubmitRequest.Raw {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends schemas.submission.StopRequest.Raw {
    type: \\"stop\\";
  }
}
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionResponse: core.schemas.Schema<SubmissionResponse.Raw, TraceApi.submission.SubmissionResponse> =
  core.schemas
    .union(\\"type\\", {
      serverInitialized: core.schemas.object({}),
      problemInitialized: core.schemas.object({
        value: core.schemas.lazy(() => schemas.commons.ProblemId),
      }),
      workspaceInitialized: core.schemas.object({}),
      serverErrored: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
      codeExecutionUpdate: core.schemas.object({
        value: core.schemas.lazy(() => schemas.submission.CodeExecutionUpdate),
      }),
      terminated: core.schemas.lazyObject(() => schemas.submission.TerminatedResponse),
    })
    .transform<TraceApi.submission.SubmissionResponse>({
      parse: (value) => {
        switch (value.type) {
          case \\"serverInitialized\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.serverInitialized(),
            };
          }
          case \\"problemInitialized\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.problemInitialized(value.value),
            };
          }
          case \\"workspaceInitialized\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.workspaceInitialized(),
            };
          }
          case \\"serverErrored\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.serverErrored(value),
            };
          }
          case \\"codeExecutionUpdate\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.codeExecutionUpdate(value.value),
            };
          }
          case \\"terminated\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.terminated(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionResponse {
  type Raw =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

  interface ServerInitialized {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized {
    type: \\"problemInitialized\\";
    value: schemas.commons.ProblemId.Raw;
  }

  interface WorkspaceInitialized {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends schemas.submission.ExceptionInfo.Raw {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate {
    type: \\"codeExecutionUpdate\\";
    value: schemas.submission.CodeExecutionUpdate.Raw;
  }

  interface Terminated extends schemas.submission.TerminatedResponse.Raw {
    type: \\"terminated\\";
  }
}
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<
  SubmissionStatusForTestCase.Raw,
  TraceApi.submission.SubmissionStatusForTestCase
> = core.schemas
  .union(\\"type\\", {
    graded: core.schemas.lazyObject(() => schemas.submission.TestCaseResultWithStdout),
    gradedV2: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.TestCaseGrade),
    }),
    traced: core.schemas.lazyObject(() => schemas.submission.TracedTestCase),
  })
  .transform<TraceApi.submission.SubmissionStatusForTestCase>({
    parse: (value) => {
      switch (value.type) {
        case \\"graded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.graded(value),
          };
        }
        case \\"gradedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedV2(value.value),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusForTestCase {
  type Raw =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

  interface Graded extends schemas.submission.TestCaseResultWithStdout.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 {
    type: \\"gradedV2\\";
    value: schemas.submission.TestCaseGrade.Raw;
  }

  interface Traced extends schemas.submission.TracedTestCase.Raw {
    type: \\"traced\\";
  }
}
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionStatusV2: core.schemas.Schema<SubmissionStatusV2.Raw, TraceApi.submission.SubmissionStatusV2> =
  core.schemas
    .union(\\"type\\", {
      test: core.schemas.lazyObject(() => schemas.submission.TestSubmissionStatusV2),
      workspace: core.schemas.lazyObject(() => schemas.submission.WorkspaceSubmissionStatusV2),
    })
    .transform<TraceApi.submission.SubmissionStatusV2>({
      parse: (value) => {
        switch (value.type) {
          case \\"test\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.test(value),
            };
          }
          case \\"workspace\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.workspace(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionStatusV2 {
  type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

  interface Test extends schemas.submission.TestSubmissionStatusV2.Raw {
    type: \\"test\\";
  }

  interface Workspace extends schemas.submission.WorkspaceSubmissionStatusV2.Raw {
    type: \\"workspace\\";
  }
}
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<SubmissionTypeEnum.Raw, TraceApi.submission.SubmissionTypeEnum> =
  core.schemas.string().transform<TraceApi.submission.SubmissionTypeEnum>({
    parse: (value) => {
      switch (value) {
        case \\"TEST\\": {
          return TraceApi.submission.SubmissionTypeEnum.Test;
        }
        default: {
          return {
            toString: () => value,
            visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value.toString(),
  });

export declare namespace SubmissionTypeEnum {
  type Raw = string;
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionTypeState: core.schemas.Schema<
  SubmissionTypeState.Raw,
  TraceApi.submission.SubmissionTypeState
> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(() => schemas.submission.TestSubmissionState),
    workspace: core.schemas.lazyObject(() => schemas.submission.WorkspaceSubmissionState),
  })
  .transform<TraceApi.submission.SubmissionTypeState>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.test(value),
          };
        }
        case \\"workspace\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspace(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionTypeState {
  type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

  interface Test extends schemas.submission.TestSubmissionState.Raw {
    type: \\"test\\";
  }

  interface Workspace extends schemas.submission.WorkspaceSubmissionState.Raw {
    type: \\"workspace\\";
  }
}
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<SubmitRequestV2.Raw, TraceApi.submission.SubmitRequestV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    language: core.schemas.lazy(() => schemas.commons.Language),
    submissionFiles: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.SubmissionFileInfo)),
    problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
    problemVersion: core.schemas.number().optional(),
    userId: core.schemas.string().optional(),
  });

export declare namespace SubmitRequestV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    language: schemas.commons.Language.Raw;
    submissionFiles: schemas.submission.SubmissionFileInfo.Raw[];
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion?: number | null;
    userId?: string | null;
  }
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TerminatedResponse: core.schemas.ObjectSchema<
  TerminatedResponse.Raw,
  TraceApi.submission.TerminatedResponse
> = core.schemas.object({});

export declare namespace TerminatedResponse {
  interface Raw {}
}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseGrade: core.schemas.Schema<TestCaseGrade.Raw, TraceApi.submission.TestCaseGrade> = core.schemas
  .union(\\"type\\", {
    hidden: core.schemas.lazyObject(() => schemas.submission.TestCaseHiddenGrade),
    nonHidden: core.schemas.lazyObject(() => schemas.submission.TestCaseNonHiddenGrade),
  })
  .transform<TraceApi.submission.TestCaseGrade>({
    parse: (value) => {
      switch (value.type) {
        case \\"hidden\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.hidden(value),
          };
        }
        case \\"nonHidden\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nonHidden(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseGrade {
  type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

  interface Hidden extends schemas.submission.TestCaseHiddenGrade.Raw {
    type: \\"hidden\\";
  }

  interface NonHidden extends schemas.submission.TestCaseNonHiddenGrade.Raw {
    type: \\"nonHidden\\";
  }
}
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<
  TestCaseHiddenGrade.Raw,
  TraceApi.submission.TestCaseHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
});

export declare namespace TestCaseHiddenGrade {
  interface Raw {
    passed: boolean;
  }
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<
  TestCaseNonHiddenGrade.Raw,
  TraceApi.submission.TestCaseNonHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
  actualResult: core.schemas.lazy(() => schemas.commons.VariableValue).optional(),
  exception: core.schemas.lazy(() => schemas.submission.ExceptionV2).optional(),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseNonHiddenGrade {
  interface Raw {
    passed: boolean;
    actualResult?: schemas.commons.VariableValue.Raw | null;
    exception?: schemas.submission.ExceptionV2.Raw | null;
    stdout: string;
  }
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseResult: core.schemas.ObjectSchema<TestCaseResult.Raw, TraceApi.submission.TestCaseResult> =
  core.schemas.object({
    expectedResult: core.schemas.lazy(() => schemas.commons.VariableValue),
    actualResult: core.schemas.lazy(() => schemas.submission.ActualResult),
    passed: core.schemas.boolean(),
  });

export declare namespace TestCaseResult {
  interface Raw {
    expectedResult: schemas.commons.VariableValue.Raw;
    actualResult: schemas.submission.ActualResult.Raw;
    passed: boolean;
  }
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<
  TestCaseResultWithStdout.Raw,
  TraceApi.submission.TestCaseResultWithStdout
> = core.schemas.object({
  result: core.schemas.lazyObject(() => schemas.submission.TestCaseResult),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseResultWithStdout {
  interface Raw {
    result: schemas.submission.TestCaseResult.Raw;
    stdout: string;
  }
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionState: core.schemas.ObjectSchema<
  TestSubmissionState.Raw,
  TraceApi.submission.TestSubmissionState
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  defaultTestCases: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.TestCase)),
  customTestCases: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.TestCase)),
  status: core.schemas.lazy(() => schemas.submission.TestSubmissionStatus),
});

export declare namespace TestSubmissionState {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    defaultTestCases: schemas.commons.TestCase.Raw[];
    customTestCases: schemas.commons.TestCase.Raw[];
    status: schemas.submission.TestSubmissionStatus.Raw;
  }
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionStatus: core.schemas.Schema<
  TestSubmissionStatus.Raw,
  TraceApi.submission.TestSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    testCaseIdToState: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazy(() => schemas.submission.SubmissionStatusForTestCase)
      ),
    }),
  })
  .transform<TraceApi.submission.TestSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"testCaseIdToState\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.testCaseIdToState(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionStatus {
  type Raw =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface TestCaseIdToState {
    type: \\"testCaseIdToState\\";
    value: Record<string, schemas.submission.SubmissionStatusForTestCase.Raw>;
  }
}
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<
  TestSubmissionStatusV2.Raw,
  TraceApi.submission.TestSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TestSubmissionUpdate)),
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemVersion: core.schemas.number(),
  problemInfo: core.schemas.lazyObject(() => schemas.v2.problem.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
  interface Raw {
    updates: schemas.submission.TestSubmissionUpdate.Raw[];
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion: number;
    problemInfo: schemas.v2.problem.ProblemInfoV2.Raw;
  }
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<
  TestSubmissionUpdate.Raw,
  TraceApi.submission.TestSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(() => schemas.submission.TestSubmissionUpdateInfo),
});

export declare namespace TestSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: schemas.submission.TestSubmissionUpdateInfo.Raw;
  }
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<
  TestSubmissionUpdateInfo.Raw,
  TraceApi.submission.TestSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    gradedTestCase: core.schemas.lazyObject(() => schemas.submission.GradedTestCaseUpdate),
    recordedTestCase: core.schemas.lazyObject(() => schemas.submission.RecordedTestCaseUpdate),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.submission.TestSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"gradedTestCase\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedTestCase(value),
          };
        }
        case \\"recordedTestCase\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recordedTestCase(value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionUpdateInfo {
  type Raw =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface GradedTestCase extends schemas.submission.GradedTestCaseUpdate.Raw {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends schemas.submission.RecordedTestCaseUpdate.Raw {
    type: \\"recordedTestCase\\";
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponse: core.schemas.ObjectSchema<TraceResponse.Raw, TraceApi.submission.TraceResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    lineNumber: core.schemas.number(),
    returnValue: core.schemas.lazy(() => schemas.commons.DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(() => schemas.submission.ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(() => schemas.submission.StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    lineNumber: number;
    returnValue?: schemas.commons.DebugVariableValue.Raw | null;
    expressionLocation?: schemas.submission.ExpressionLocation.Raw | null;
    stack: schemas.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponseV2: core.schemas.ObjectSchema<TraceResponseV2.Raw, TraceApi.submission.TraceResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
    lineNumber: core.schemas.number(),
    file: core.schemas.lazyObject(() => schemas.submission.TracedFile),
    returnValue: core.schemas.lazy(() => schemas.commons.DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(() => schemas.submission.ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(() => schemas.submission.StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponseV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    lineNumber: number;
    file: schemas.submission.TracedFile.Raw;
    returnValue?: schemas.commons.DebugVariableValue.Raw | null;
    expressionLocation?: schemas.submission.ExpressionLocation.Raw | null;
    stack: schemas.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<
  TraceResponsesPage.Raw,
  TraceApi.submission.TraceResponsesPage
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponse)),
});

export declare namespace TraceResponsesPage {
  interface Raw {
    offset?: number | null;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<
  TraceResponsesPageV2.Raw,
  TraceApi.submission.TraceResponsesPageV2
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)),
});

export declare namespace TraceResponsesPageV2 {
  interface Raw {
    offset?: number | null;
    traceResponses: schemas.submission.TraceResponseV2.Raw[];
  }
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TracedFile: core.schemas.ObjectSchema<TracedFile.Raw, TraceApi.submission.TracedFile> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
  });

export declare namespace TracedFile {
  interface Raw {
    filename: string;
    directory: string;
  }
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TracedTestCase: core.schemas.ObjectSchema<TracedTestCase.Raw, TraceApi.submission.TracedTestCase> =
  core.schemas.object({
    result: core.schemas.lazyObject(() => schemas.submission.TestCaseResultWithStdout),
    traceResponsesSize: core.schemas.number(),
  });

export declare namespace TracedTestCase {
  interface Raw {
    result: schemas.submission.TestCaseResultWithStdout.Raw;
    traceResponsesSize: number;
  }
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<
  UnexpectedLanguageError.Raw,
  TraceApi.submission.UnexpectedLanguageError
> = core.schemas.object({
  expectedLanguage: core.schemas.lazy(() => schemas.commons.Language),
  actualLanguage: core.schemas.lazy(() => schemas.commons.Language),
});

export declare namespace UnexpectedLanguageError {
  interface Raw {
    expectedLanguage: schemas.commons.Language.Raw;
    actualLanguage: schemas.commons.Language.Raw;
  }
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<WorkspaceFiles.Raw, TraceApi.submission.WorkspaceFiles> =
  core.schemas.object({
    mainFile: core.schemas.lazyObject(() => schemas.commons.FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => schemas.commons.FileInfo)),
  });

export declare namespace WorkspaceFiles {
  interface Raw {
    mainFile: schemas.commons.FileInfo.Raw;
    readOnlyFiles: schemas.commons.FileInfo.Raw[];
  }
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<
  WorkspaceRanResponse.Raw,
  TraceApi.submission.WorkspaceRanResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  runDetails: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
});

export declare namespace WorkspaceRanResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    runDetails: schemas.submission.WorkspaceRunDetails.Raw;
  }
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<
  WorkspaceRunDetails.Raw,
  TraceApi.submission.WorkspaceRunDetails
> = core.schemas.object({
  exceptionV2: core.schemas.lazy(() => schemas.submission.ExceptionV2).optional(),
  exception: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo).optional(),
  stdout: core.schemas.string(),
});

export declare namespace WorkspaceRunDetails {
  interface Raw {
    exceptionV2?: schemas.submission.ExceptionV2.Raw | null;
    exception?: schemas.submission.ExceptionInfo.Raw | null;
    stdout: string;
  }
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponse.Raw,
  TraceApi.submission.WorkspaceStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.submission.WorkspaceFiles)
  ),
});

export declare namespace WorkspaceStarterFilesResponse {
  interface Raw {
    files: Record<schemas.commons.Language.Raw, schemas.submission.WorkspaceFiles.Raw>;
  }
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponseV2.Raw,
  TraceApi.submission.WorkspaceStarterFilesResponseV2
> = core.schemas.object({
  filesByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
  interface Raw {
    filesByLanguage: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
  }
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<
  WorkspaceSubmissionState.Raw,
  TraceApi.submission.WorkspaceSubmissionState
> = core.schemas.object({
  status: core.schemas.lazy(() => schemas.submission.WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
  interface Raw {
    status: schemas.submission.WorkspaceSubmissionStatus.Raw;
  }
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<
  WorkspaceSubmissionStatus.Raw,
  TraceApi.submission.WorkspaceSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
    traced: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
  })
  .transform<TraceApi.submission.WorkspaceSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"ran\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.ran(value),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionStatus {
  type Raw =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Traced extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"traced\\";
  }
}
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<
  WorkspaceSubmissionStatusV2.Raw,
  TraceApi.submission.WorkspaceSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.WorkspaceSubmissionUpdate)),
});

export declare namespace WorkspaceSubmissionStatusV2 {
  interface Raw {
    updates: schemas.submission.WorkspaceSubmissionUpdate.Raw[];
  }
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<
  WorkspaceSubmissionUpdate.Raw,
  TraceApi.submission.WorkspaceSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(() => schemas.submission.WorkspaceSubmissionUpdateInfo),
});

export declare namespace WorkspaceSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: schemas.submission.WorkspaceSubmissionUpdateInfo.Raw;
  }
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<
  WorkspaceSubmissionUpdateInfo.Raw,
  TraceApi.submission.WorkspaceSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
    stopped: core.schemas.object({}),
    traced: core.schemas.object({}),
    tracedV2: core.schemas.lazyObject(() => schemas.submission.WorkspaceTracedUpdate),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.submission.WorkspaceSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"ran\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.ran(value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(),
          };
        }
        case \\"tracedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.tracedV2(value),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionUpdateInfo {
  type Raw =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Traced {
    type: \\"traced\\";
  }

  interface TracedV2 extends schemas.submission.WorkspaceTracedUpdate.Raw {
    type: \\"tracedV2\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<
  WorkspaceSubmitRequest.Raw,
  TraceApi.submission.WorkspaceSubmitRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  language: core.schemas.lazy(() => schemas.commons.Language),
  submissionFiles: core.schemas.list(core.schemas.lazyObject(() => schemas.submission.SubmissionFileInfo)),
  userId: core.schemas.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    language: schemas.commons.Language.Raw;
    submissionFiles: schemas.submission.SubmissionFileInfo.Raw[];
    userId?: string | null;
  }
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<
  WorkspaceTracedUpdate.Raw,
  TraceApi.submission.WorkspaceTracedUpdate
> = core.schemas.object({
  traceResponsesSize: core.schemas.number(),
});

export declare namespace WorkspaceTracedUpdate {
  interface Raw {
    traceResponsesSize: number;
  }
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  Record<schemas.commons.Language.Raw, number>,
  Record<TraceApi.commons.Language.RawValue, number>
> = core.schemas.record(core.schemas.string(), core.schemas.number());
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../..\\";
import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.LightweightProblemInfoV2.Raw[],
  TraceApi.v2.problem.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.LightweightProblemInfoV2));
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../..\\";
import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.ProblemInfoV2.Raw[],
  TraceApi.v2.problem.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.ProblemInfoV2));
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceApi.v2.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => schemas.v2.problem.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceApi.v2.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.deepEquality(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends schemas.v2.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, TraceApi.v2.problem.BasicCustomFiles> =
  core.schemas.object({
    methodName: core.schemas.string(),
    signature: core.schemas.lazyObject(() => schemas.v2.problem.NonVoidFunctionSignature),
    additionalFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.problem.Files)
    ),
    basicTestCaseTemplate: core.schemas.lazyObject(() => schemas.v2.problem.BasicTestCaseTemplate),
  });

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    basicTestCaseTemplate: schemas.v2.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceApi.v2.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    description: schemas.v2.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceApi.v2.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
  customFiles: core.schemas.lazy(() => schemas.v2.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => schemas.commons.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    customFiles: schemas.v2.problem.CustomFiles.Raw;
    customTestCaseTemplates: schemas.v2.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.problem.TestCaseV2.Raw[];
    supportedLanguages: schemas.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceApi.v2.problem.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => schemas.v2.problem.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => schemas.v2.problem.Files)
      ),
    }),
  })
  .transform<TraceApi.v2.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.basic(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends schemas.v2.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
  }
}
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  TraceApi.v2.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: schemas.v2.problem.FileInfoV2.Raw;
    relatedTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceApi.v2.problem.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceApi.v2.problem.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: schemas.v2.problem.FileInfoV2.Raw[];
  }
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceApi.v2.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<schemas.commons.Language.Raw, schemas.v2.problem.FunctionImplementation.Raw>;
  }
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceApi.v2.problem.FunctionSignature> =
  core.schemas
    .union(\\"type\\", {
      void: core.schemas.lazyObject(() => schemas.v2.problem.VoidFunctionSignature),
      nonVoid: core.schemas.lazyObject(() => schemas.v2.problem.NonVoidFunctionSignature),
      voidThatTakesActualResult: core.schemas.lazyObject(
        () => schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult
      ),
    })
    .transform<TraceApi.v2.problem.FunctionSignature>({
      parse: (value) => {
        switch (value.type) {
          case \\"void\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.void(value),
            };
          }
          case \\"nonVoid\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.nonVoid(value),
            };
          }
          case \\"voidThatTakesActualResult\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.voidThatTakesActualResult(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends schemas.v2.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends schemas.v2.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceApi.v2.problem.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.problem.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.problem.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.problem.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    generatedTemplateFiles: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    other: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
  }
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => schemas.v2.problem.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<schemas.commons.Language.Raw, schemas.v2.problem.FileInfoV2.Raw>;
  }
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceApi.v2.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => schemas.v2.problem.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: schemas.v2.problem.FunctionSignature.Raw;
  }
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceApi.v2.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<schemas.commons.Language.Raw, string>;
  }
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: schemas.v2.problem.TestCaseTemplate.Raw | null;
    testCase: schemas.v2.problem.TestCaseV2.Raw;
  }
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: schemas.v2.problem.TestCaseTemplate.Raw;
  }
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceApi.v2.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceApi.v2.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => schemas.v2.problem.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => schemas.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceApi.v2.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.Parameter)),
  returnType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    returnType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceApi.v2.problem.Parameter> = core.schemas.object({
  parameterId: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
  name: core.schemas.string(),
  variableType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace Parameter {
  interface Raw {
    parameterId: schemas.v2.problem.ParameterId.Raw;
    name: string;
    variableType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceApi.v2.problem.ParameterId> = core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceApi.v2.problem.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => schemas.commons.Language)),
    customFiles: core.schemas.lazy(() => schemas.v2.problem.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => schemas.v2.problem.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate)),
    testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: schemas.commons.Language.Raw[];
    customFiles: schemas.v2.problem.CustomFiles.Raw;
    generatedFiles: schemas.v2.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: schemas.v2.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceApi.v2.problem.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceApi.v2.problem.TestCaseFunction> =
  core.schemas
    .union(\\"type\\", {
      withActualResult: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseWithActualResultImplementation),
      custom: core.schemas.lazyObject(() => schemas.v2.problem.VoidFunctionDefinition),
    })
    .transform<TraceApi.v2.problem.TestCaseFunction>({
      parse: (value) => {
        switch (value.type) {
          case \\"withActualResult\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.withActualResult(value),
            };
          }
          case \\"custom\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.custom(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends schemas.v2.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends schemas.v2.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceApi.v2.problem.TestCaseId> = core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceApi.v2.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => schemas.v2.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: schemas.v2.problem.TestCaseImplementationDescription.Raw;
    function: schemas.v2.problem.TestCaseFunction.Raw;
  }
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceApi.v2.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => schemas.v2.problem.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: schemas.v2.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
    }),
  })
  .transform<TraceApi.v2.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"paramId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.paramId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceApi.v2.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseImplementation),
  })
  .transform<TraceApi.v2.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.templateId(value.value),
          };
        }
        case \\"implementation\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.implementation(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: schemas.v2.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation extends schemas.v2.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, TraceApi.v2.problem.TestCaseMetadata> =
  core.schemas.object({
    id: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
    name: core.schemas.string(),
    hidden: core.schemas.boolean(),
  });

export declare namespace TestCaseMetadata {
  interface Raw {
    id: schemas.v2.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, TraceApi.v2.problem.TestCaseTemplate> =
  core.schemas.object({
    templateId: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
    name: core.schemas.string(),
    implementation: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseImplementation),
  });

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: schemas.v2.problem.TestCaseImplementation.Raw;
  }
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, TraceApi.v2.problem.TestCaseTemplateId> =
  core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceApi.v2.problem.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseMetadata),
    implementation: core.schemas.lazy(() => schemas.v2.problem.TestCaseImplementationReference),
    arguments: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => schemas.commons.VariableValue)
    ),
    expects: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: schemas.v2.problem.TestCaseMetadata.Raw;
    implementation: schemas.v2.problem.TestCaseImplementationReference.Raw;
    arguments: Record<schemas.v2.problem.ParameterId.Raw, schemas.commons.VariableValue.Raw>;
    expects?: schemas.v2.problem.TestCaseExpects.Raw | null;
  }
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => schemas.v2.problem.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => schemas.v2.problem.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: schemas.v2.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: schemas.v2.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceApi.v2.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.Parameter)),
  code: core.schemas.lazyObject(() => schemas.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.Parameter)),
  code: core.schemas.lazyObject(() => schemas.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: schemas.v2.problem.Parameter.Raw[];
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceApi.v2.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
  }
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.problem.Parameter)),
  actualResultType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    actualResultType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../../..\\";
import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[],
  TraceApi.v2.v3.problem.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.LightweightProblemInfoV2));
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../../..\\";
import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.ProblemInfoV2.Raw[],
  TraceApi.v2.v3.problem.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.ProblemInfoV2));
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceApi.v2.v3.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => schemas.v2.v3.problem.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceApi.v2.v3.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.deepEquality(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends schemas.v2.v3.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  BasicCustomFiles.Raw,
  TraceApi.v2.v3.problem.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => schemas.v2.v3.problem.NonVoidFunctionSignature),
  additionalFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(() => schemas.v2.v3.problem.BasicTestCaseTemplate),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
    basicTestCaseTemplate: schemas.v2.v3.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceApi.v2.v3.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    description: schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceApi.v2.v3.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
  customFiles: core.schemas.lazy(() => schemas.v2.v3.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => schemas.commons.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    customFiles: schemas.v2.v3.problem.CustomFiles.Raw;
    customTestCaseTemplates: schemas.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.v3.problem.TestCaseV2.Raw[];
    supportedLanguages: schemas.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceApi.v2.v3.problem.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => schemas.v2.v3.problem.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
      ),
    }),
  })
  .transform<TraceApi.v2.v3.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.basic(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends schemas.v2.v3.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
  }
}
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.v3.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  TraceApi.v2.v3.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: schemas.v2.v3.problem.FileInfoV2.Raw;
    relatedTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceApi.v2.v3.problem.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceApi.v2.v3.problem.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: schemas.v2.v3.problem.FileInfoV2.Raw[];
  }
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceApi.v2.v3.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.v3.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.FunctionImplementation.Raw>;
  }
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceApi.v2.v3.problem.FunctionSignature> =
  core.schemas
    .union(\\"type\\", {
      void: core.schemas.lazyObject(() => schemas.v2.v3.problem.VoidFunctionSignature),
      nonVoid: core.schemas.lazyObject(() => schemas.v2.v3.problem.NonVoidFunctionSignature),
      voidThatTakesActualResult: core.schemas.lazyObject(
        () => schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
      ),
    })
    .transform<TraceApi.v2.v3.problem.FunctionSignature>({
      parse: (value) => {
        switch (value.type) {
          case \\"void\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.void(value),
            };
          }
          case \\"nonVoid\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.nonVoid(value),
            };
          }
          case \\"voidThatTakesActualResult\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.voidThatTakesActualResult(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends schemas.v2.v3.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends schemas.v2.v3.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceApi.v2.v3.problem.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
    generatedTemplateFiles: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
    other: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
  }
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.v3.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => schemas.v2.v3.problem.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.v3.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.FileInfoV2.Raw>;
  }
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceApi.v2.v3.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => schemas.v2.v3.problem.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: schemas.v2.v3.problem.FunctionSignature.Raw;
  }
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceApi.v2.v3.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<schemas.commons.Language.Raw, string>;
  }
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.v3.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: schemas.v2.v3.problem.TestCaseTemplate.Raw | null;
    testCase: schemas.v2.v3.problem.TestCaseV2.Raw;
  }
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.v3.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: schemas.v2.v3.problem.TestCaseTemplate.Raw;
  }
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceApi.v2.v3.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => schemas.commons.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceApi.v2.v3.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => schemas.v2.v3.problem.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceApi.v2.v3.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)),
  returnType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    returnType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceApi.v2.v3.problem.Parameter> =
  core.schemas.object({
    parameterId: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
    name: core.schemas.string(),
    variableType: core.schemas.lazy(() => schemas.commons.VariableType),
  });

export declare namespace Parameter {
  interface Raw {
    parameterId: schemas.v2.v3.problem.ParameterId.Raw;
    name: string;
    variableType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceApi.v2.v3.problem.ParameterId> =
  core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceApi.v2.v3.problem.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => schemas.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => schemas.commons.Language)),
    customFiles: core.schemas.lazy(() => schemas.v2.v3.problem.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => schemas.v2.v3.problem.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate)),
    testcases: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: schemas.commons.Language.Raw[];
    customFiles: schemas.v2.v3.problem.CustomFiles.Raw;
    generatedFiles: schemas.v2.v3.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: schemas.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.v3.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceApi.v2.v3.problem.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceApi.v2.v3.problem.TestCaseFunction> =
  core.schemas
    .union(\\"type\\", {
      withActualResult: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseWithActualResultImplementation),
      custom: core.schemas.lazyObject(() => schemas.v2.v3.problem.VoidFunctionDefinition),
    })
    .transform<TraceApi.v2.v3.problem.TestCaseFunction>({
      parse: (value) => {
        switch (value.type) {
          case \\"withActualResult\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.withActualResult(value),
            };
          }
          case \\"custom\\": {
            return {
              ...value,
              _visit: (visitor) => visitor.custom(value),
            };
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends schemas.v2.v3.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends schemas.v2.v3.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceApi.v2.v3.problem.TestCaseId> = core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceApi.v2.v3.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
    function: schemas.v2.v3.problem.TestCaseFunction.Raw;
  }
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceApi.v2.v3.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.v3.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
    }),
  })
  .transform<TraceApi.v2.v3.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"paramId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.paramId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceApi.v2.v3.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseImplementation),
  })
  .transform<TraceApi.v2.v3.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.templateId(value.value),
          };
        }
        case \\"implementation\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.implementation(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation extends schemas.v2.v3.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  TestCaseMetadata.Raw,
  TraceApi.v2.v3.problem.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: schemas.v2.v3.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  TestCaseTemplate.Raw,
  TraceApi.v2.v3.problem.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseImplementation),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: schemas.v2.v3.problem.TestCaseImplementation.Raw;
  }
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  TestCaseTemplateId.Raw,
  TraceApi.v2.v3.problem.TestCaseTemplateId
> = core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceApi.v2.v3.problem.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseMetadata),
    implementation: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseImplementationReference),
    arguments: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => schemas.commons.VariableValue)
    ),
    expects: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: schemas.v2.v3.problem.TestCaseMetadata.Raw;
    implementation: schemas.v2.v3.problem.TestCaseImplementationReference.Raw;
    arguments: Record<schemas.v2.v3.problem.ParameterId.Raw, schemas.commons.VariableValue.Raw>;
    expects?: schemas.v2.v3.problem.TestCaseExpects.Raw | null;
  }
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.v3.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => schemas.v2.v3.problem.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => schemas.v2.v3.problem.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: schemas.v2.v3.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: schemas.v2.v3.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceApi.v2.v3.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)),
  code: core.schemas.lazyObject(() => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)),
  code: core.schemas.lazyObject(() => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: schemas.v2.v3.problem.Parameter.Raw[];
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceApi.v2.v3.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
  }
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)),
  actualResultType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    actualResultType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "schemas",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
